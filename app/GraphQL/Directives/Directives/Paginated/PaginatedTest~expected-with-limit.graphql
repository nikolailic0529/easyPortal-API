input AssetsSearchCustomerSort {
  name: String
}

input AssetsSearchProductSort {
  sku: String
  name: String
}

input AssetsSearchSort {
  serial_number: String
  product: AssetsSearchProductSort
  customer: AssetsSearchCustomerSort
}

input CustomersSearchHeadquarterCitySort {
  name: String
}

input CustomersSearchHeadquarterSort {
  city: CustomersSearchHeadquarterCitySort
}

input CustomersSearchSort {
  name: String
  assets_count: String
  locations_count: String
  headquarter: CustomersSearchHeadquarterSort
}

input DocumentsSearchCustomerSort {
  name: String
}

input DocumentsSearchSort {
  number: String
  start: String
  end: String
  price: String
  customer: DocumentsSearchCustomerSort
}

type Object {
  id: ID!
}

"""Aggregated query for type Object."""
type ObjectAggregated {
  count: Int!
}

input ObjectSearch {
  id: ID!
}

"""Information about pagination using a Relay style cursor connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """The cursor to continue paginating backwards."""
  startCursor: String

  """The cursor to continue paginating forwards."""
  endCursor: String

  """Total number of nodes in the paginated connection."""
  total: Int!

  """Number of nodes in the current page."""
  count: Int!

  """Index of the current page."""
  currentPage: Int!

  """Index of the last available page."""
  lastPage: Int!
}

"""Information about pagination using a fully featured paginator."""
type PaginatorInfo {
  """Number of items in the current page."""
  count: Int!

  """Index of the current page."""
  currentPage: Int!

  """Index of the first item in the current page."""
  firstItem: Int

  """Are there more pages after this one?"""
  hasMorePages: Boolean!

  """Index of the last item in the current page."""
  lastItem: Int

  """Index of the last available page."""
  lastPage: Int!

  """Number of items per page."""
  perPage: Int!

  """Number of total available items."""
  total: Int!
}

type Query {
  """@require <me> User must be authenticated."""
  query(
    where: SearchByConditionObjectSearch
    order: [SortByClauseObject!]
    test: ID

    """Maximum value is 123."""
    limit: Int! = 25
    offset: Int! = 0
  ): [Object!]!

  """@require <me> User must be authenticated."""
  queryAggregated(where: SearchByConditionObjectSearch): ObjectAggregated
}

"""
Available conditions for input ObjectSearch (only one property allowed at a time).
"""
input SearchByConditionObjectSearch {
  """All of the conditions must be true."""
  allOf: [SearchByConditionObjectSearch!]

  """Any of the conditions must be true."""
  anyOf: [SearchByConditionObjectSearch!]

  """Not."""
  not: SearchByConditionObjectSearch

  """Property condition."""
  id: SearchByScalarID
}

"""
Available operators for scalar ID! (only one operator allowed at a time).
"""
input SearchByScalarID {
  """Equal (`=`)."""
  equal: ID

  """Not Equal (`!=`)."""
  notEqual: ID

  """Within a set of values."""
  in: [ID!]

  """Outside a set of values."""
  notIn: [ID!]
}

"""Information about pagination using a simple paginator."""
type SimplePaginatorInfo {
  """Number of items in the current page."""
  count: Int!

  """Index of the current page."""
  currentPage: Int!

  """Index of the first item in the current page."""
  firstItem: Int

  """Index of the last item in the current page."""
  lastItem: Int

  """Number of items per page."""
  perPage: Int!
}

"""Sort clause for type Object (only one property allowed at a time)."""
input SortByClauseObject {
  """Property clause."""
  id: SortByDirection
}

"""Sort direction."""
enum SortByDirection {
  asc
  desc
}
