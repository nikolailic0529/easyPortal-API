"""
Sort direction.
"""
enum AggregatedGroupByTypeDirection {
    asc
    desc
}

enum CachedMode {
    """
    In this mode all queries will be cached always.
    """
    Normal

    """
    In this mode, the query will be cached only if the execution time is
    greater than the threshold.
    """
    Threshold
}

"""
Sort direction.
"""
enum SortByTypeDirection {
    asc
    desc
}

"""
Group clause for `type Asset` (only one property allowed at a time).
"""
input AggregatedGroupByClauseAsset {
    """
    Property clause.
    """
    id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorProperty
}

"""
Group clause for `input CustomerSearch` (only one property allowed at a time).
"""
input AggregatedGroupByClauseCustomerSearch {
    """
    Property clause.
    """
    id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorProperty
}

"""
Group clause for `type Type` (only one property allowed at a time).
"""
input AggregatedGroupByClauseType {
    """
    Property clause.
    """
    id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorProperty
}

"""
Input for the `messages` argument of `@rules`.
"""
input RulesMessage {
    """
    Message to display if the rule fails, e.g. `"Must be a valid email"`.
    """
    message: String!

    """
    Name of the rule, e.g. `"email"`.
    """
    rule: String!
}

"""
Available conditions for `input CustomerSearch` (only one property allowed at a time).
"""
input SearchByConditionCustomerSearch {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionCustomerSearch!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionCustomerSearch!]
    @searchByOperatorAnyOf

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionCustomerSearch
    @searchByOperatorNot
}

"""
Available operators for `scalar ID!` (only one operator allowed at a time).
"""
input SearchByScalarID {
    """
    Equal (`=`).
    """
    equal: ID
    @searchByOperatorEqual

    """
    Within a set of values.
    """
    in: [ID!]
    @searchByOperatorIn

    """
    Not Equal (`!=`).
    """
    notEqual: ID
    @searchByOperatorNotEqual

    """
    Outside a set of values.
    """
    notIn: [ID!]
    @searchByOperatorNotIn
}

"""
Sort clause for type Customer (only one property allowed at a time).
"""
input SortByClauseCustomer {
    """
    Property clause.
    """
    id: SortByTypeDirection
    @sortByOperatorProperty
}

type AggregatedGroupByTypeGroup {
    count: Int!
    key: String
}

"""
Aggregated data for `type AggregatedGroupByTypeGroup`.
"""
type AggregatedGroupByTypeGroupsAggregated {
    count: Int!
    @aggregatedCount
    @cached(
        mode: Threshold
    )
}

type Asset {
    id: ID!
}

"""
Aggregated data for `type Asset`.
"""
type AssetsAggregated {
    count: Int!
    @aggregatedCount
    @cached(
        mode: Threshold
    )

    groups(
        groupBy: AggregatedGroupByClauseAsset!
        @aggregatedGroupBy

        limit: Int!
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset
    ): [AggregatedGroupByTypeGroup!]!
    @cached(
        mode: Threshold
    )
    @paginated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )

    groupsAggregated(
        groupBy: AggregatedGroupByClauseAsset!
        @aggregatedGroupBy
    ): AggregatedGroupByTypeGroupsAggregated
    @aggregated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )

    types: [String!]!
}

type Customer {
    id: ID!
}

"""
Aggregated data for `type Customer`.
"""
type CustomersAggregated {
    count: Int!
    @aggregatedCount
    @cached(
        mode: Threshold
    )

    groups(
        groupBy: AggregatedGroupByClauseCustomerSearch!
        @aggregatedGroupBy

        limit: Int!
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset
    ): [AggregatedGroupByTypeGroup!]!
    @cached(
        mode: Threshold
    )
    @paginated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )

    groupsAggregated(
        groupBy: AggregatedGroupByClauseCustomerSearch!
        @aggregatedGroupBy
    ): AggregatedGroupByTypeGroupsAggregated
    @aggregated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )
}

type Query {
    data(
        limit: Int!
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset
    ): [Asset!]!
    @paginated

    dataAggregated: AssetsAggregated
    @aggregated(
        model: "App\\Models\\Asset"
    )

    """
    @require <authMe> User must be authenticated.
    """
    query(
        limit: Int!
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseCustomer!]
        @sortBy

        test: ID

        where: SearchByConditionCustomerSearch
        @searchBy
    ): [Customer!]!
    @authMe
    @paginated

    """
    @require <authMe> User must be authenticated.
    """
    queryAggregated(
        where: SearchByConditionCustomerSearch
        @searchBy
    ): CustomersAggregated
    @authMe
    @aggregated(
        model: "App\\Models\\Customer"
    )

    type(
        limit: Int!
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset
    ): [Type!]!
    @paginated

    typeAggregated: TypesAggregated
    @aggregated(
        model: "App\\Models\\Type"
    )
}

type Type {
    id: ID!
}

"""
Description
"""
type TypesAggregated {
    assets: [ID!]!

    count: Int!
    @aggregatedCount
    @cached(
        mode: Threshold
    )

    groups(
        groupBy: AggregatedGroupByClauseType!
        @aggregatedGroupBy

        limit: Int!
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset
    ): [AggregatedGroupByTypeGroup!]!
    @cached(
        mode: Threshold
    )
    @paginated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )

    groupsAggregated(
        groupBy: AggregatedGroupByClauseType!
        @aggregatedGroupBy
    ): AggregatedGroupByTypeGroupsAggregated
    @aggregated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )
}

"""
Gets the current builder and passed it to children. At least one argument required.
"""
directive @aggregated(
    """
    Point to a function that provides a Query Builder instance.
    This replaces the use of a model.
    """
    builder: String

    """
    Specify the class name of the model to use.
    This is only needed when the default model detection does not work.
    """
    model: String

    """
    Specify the relation name to use.
    """
    relation: String
)
on
    | FIELD_DEFINITION

"""
Returns `count(*)`.
"""
directive @aggregatedCount
on
    | FIELD_DEFINITION

directive @aggregatedGroupBy
on
    | ARGUMENT_DEFINITION

directive @aggregatedGroupByOperatorProperty
on
    | INPUT_FIELD_DEFINITION

"""
User must be authenticated.
"""
directive @authMe(
    """
    User must be authenticated and have any of these permissions.
    """
    permissions: [String!]
)
repeatable on
    | FIELD_DEFINITION
    | OBJECT

"""
Cache the resolved value of a field.
"""
directive @cached(
    mode: CachedMode
)
on
    | FIELD_DEFINITION

"""
Adds offset-based pagination for the field.
"""
directive @paginated(
    """
    Point to a function that provides a Query Builder instance.
    This replaces the use of a model.
    """
    builder: String

    """
    Specify the class name of the model to use.
    This is only needed when the default model detection does not work.
    """
    model: String
)
on
    | FIELD_DEFINITION

"""
Adds limit clause to the builder.
"""
directive @paginatedLimit
on
    | ARGUMENT_DEFINITION

"""
Adds offset clause to the builder.
"""
directive @paginatedOffset
on
    | ARGUMENT_DEFINITION

"""
Validate an argument using [Laravel validation](https://laravel.com/docs/validation).
"""
directive @rules(
    """
    Specify the validation rules to apply to the field.
    This can either be a reference to [Laravel's built-in validation rules](https://laravel.com/docs/validation#available-validation-rules),
    or the fully qualified class name of a custom validation rule.

    Rules that mutate the incoming arguments, such as `exclude_if`, are not supported
    by Lighthouse. Use ArgTransformerDirectives or FieldMiddlewareDirectives instead.
    """
    apply: [String!]!

    """
    Specify a custom attribute name to use in your validation message.
    """
    attribute: String

    """
    Specify the messages to return if the validators fail.
    """
    messages: [RulesMessage!]
)
repeatable on
    | ARGUMENT_DEFINITION
    | INPUT_FIELD_DEFINITION

"""
Use Input as Search Conditions for the current Builder.
"""
directive @searchBy
on
    | ARGUMENT_DEFINITION

directive @searchByOperatorAllOf
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorAnyOf
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorEqual
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorIn
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorNot
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorNotEqual
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorNotIn
on
    | INPUT_FIELD_DEFINITION

directive @searchByProperty
on
    | INPUT_FIELD_DEFINITION

"""
Convert Input into Sort Clause.
"""
directive @sortBy
on
    | ARGUMENT_DEFINITION

directive @sortByOperatorProperty
on
    | INPUT_FIELD_DEFINITION
