enum CachedMode {
    """
    In this mode all queries will be cached in addition the resolver will
    use Atomic Locks to reduce server load. The mode is designed for
    heavy/long queries.
    """
    Lock

    """
    In this mode, the query will be cached only if the execution time is
    greater than the threshold.
    """
    Threshold
}

"""
Options for the `type` argument of `@hasMany`.
"""
enum HasManyType {
    """
    Cursor-based pagination, compatible with the Relay specification.
    """
    CONNECTION

    """
    Offset-based pagination, similar to the Laravel default.
    """
    PAGINATOR

    """
    Offset-based pagination like the Laravel "Simple Pagination", which does not count the total number of records.
    """
    SIMPLE
}

"""
Sort direction.
"""
enum SortByDirection {
    asc
    desc
}

"""
Input for the `messages` argument of `@rules`.
"""
input RulesMessage {
    """
    Message to display if the rule fails, e.g. `"Must be a valid email"`.
    """
    message: String!

    """
    Name of the rule, e.g. `"email"`.
    """
    rule: String!
}

"""
Available conditions for input CustomerSearch (only one property allowed at a time).
"""
input SearchByConditionCustomerSearch {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionCustomerSearch!]

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionCustomerSearch!]

    """
    Property condition.
    """
    id: SearchByScalarID

    """
    Not.
    """
    not: SearchByConditionCustomerSearch
}

"""
Available operators for scalar ID! (only one operator allowed at a time).
"""
input SearchByScalarID {
    """
    Equal (`=`).
    """
    equal: ID

    """
    Within a set of values.
    """
    in: [ID!]

    """
    Not Equal (`!=`).
    """
    notEqual: ID

    """
    Outside a set of values.
    """
    notIn: [ID!]
}

"""
Sort clause for type CustomerLocation (only one property allowed at a time).
"""
input SortByClauseCustomerLocation {
    """
    Property clause.
    """
    id: SortByDirection
}

type Customer {
    id: ID!

    """
    Description
    """
    locations(
        limit: Int!
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(apply: ["min:0"])
        @paginatedOffset

        order: [SortByClauseCustomerLocation!]
        @sortBy

        test: ID

        where: SearchByConditionCustomerSearch
        @searchBy(
            operators: [
                "LastDragon_ru\\LaraASP\\GraphQL\\SearchBy\\Operators\\Logical\\AllOf"
                "LastDragon_ru\\LaraASP\\GraphQL\\SearchBy\\Operators\\Logical\\AnyOf"
                "LastDragon_ru\\LaraASP\\GraphQL\\SearchBy\\Operators\\Logical\\Not"
                "LastDragon_ru\\LaraASP\\GraphQL\\SearchBy\\Operators\\Comparison\\Equal"
                "LastDragon_ru\\LaraASP\\GraphQL\\SearchBy\\Operators\\Comparison\\NotEqual"
                "LastDragon_ru\\LaraASP\\GraphQL\\SearchBy\\Operators\\Comparison\\In"
                "LastDragon_ru\\LaraASP\\GraphQL\\SearchBy\\Operators\\Comparison\\NotIn"
            ]
        )
    ): [CustomerLocation!]
    @hasMany
    @paginatedRelation

    locationsAggregated(
        where: SearchByConditionCustomerSearch
        @searchBy(
            operators: [
                "LastDragon_ru\\LaraASP\\GraphQL\\SearchBy\\Operators\\Logical\\AllOf"
                "LastDragon_ru\\LaraASP\\GraphQL\\SearchBy\\Operators\\Logical\\AnyOf"
                "LastDragon_ru\\LaraASP\\GraphQL\\SearchBy\\Operators\\Logical\\Not"
                "LastDragon_ru\\LaraASP\\GraphQL\\SearchBy\\Operators\\Comparison\\Equal"
                "LastDragon_ru\\LaraASP\\GraphQL\\SearchBy\\Operators\\Comparison\\NotEqual"
                "LastDragon_ru\\LaraASP\\GraphQL\\SearchBy\\Operators\\Comparison\\In"
                "LastDragon_ru\\LaraASP\\GraphQL\\SearchBy\\Operators\\Comparison\\NotIn"
            ]
        )
    ): CustomerLocationsAggregated
    @aggregated(relation: "locations")
}

type CustomerLocation {
    id: ID!
}

"""
Aggregated data for type CustomerLocation.
"""
type CustomerLocationsAggregated {
    count: Int!
    @aggregatedCount
    @cached
}

type Query {
    query: [Customer!]!
    @all
}

"""
Gets the current builder and passed it to children. At least one argument required.
"""
directive @aggregated(
    """
    Point to a function that provides a Query Builder instance.
    This replaces the use of a model.
    """
    builder: String

    """
    Specify the class name of the model to use.
    This is only needed when the default model detection does not work.
    """
    model: String

    """
    Specify the relation name to use.
    """
    relation: String
)
on
    | FIELD_DEFINITION

"""
Returns `count(*)`.
"""
directive @aggregatedCount
on
    | FIELD_DEFINITION

"""
Fetch all Eloquent models and return the collection as the result.
"""
directive @all(
    """
    Point to a function that provides a Query Builder instance.
    This replaces the use of a model.
    """
    builder: String

    """
    Specify the class name of the model to use.
    This is only needed when the default model detection does not work.
    """
    model: String

    """
    Apply scopes to the underlying query.
    """
    scopes: [String!]
)
on
    | FIELD_DEFINITION

"""
Cache the resolved value of a field.
"""
directive @cached(mode: CachedMode)
on
    | FIELD_DEFINITION

"""
Corresponds to [the Eloquent relationship HasMany](https://laravel.com/docs/eloquent-relationships#one-to-many).
"""
directive @hasMany(
    """
    Allow clients to query paginated lists without specifying the amount of items.
    Overrules the `pagination.default_count` setting from `lighthouse.php`.
    """
    defaultCount: Int

    """
    Specify a custom type that implements the Edge interface
    to extend edge object.
    Only applies when using Relay style "connection" pagination.
    """
    edgeType: String

    """
    Limit the maximum amount of items that clients can request from paginated lists.
    Overrules the `pagination.max_count` setting from `lighthouse.php`.
    """
    maxCount: Int

    """
    Specify the relationship method name in the model class,
    if it is named different from the field in the schema.
    """
    relation: String

    """
    Apply scopes to the underlying query.
    """
    scopes: [String!]

    """
    Allows to resolve the relation as a paginated list.
    Allowed values: `paginator`, `connection`.
    """
    type: HasManyType
)
on
    | FIELD_DEFINITION

"""
Adds limit clause to the builder.
"""
directive @paginatedLimit
on
    | ARGUMENT_DEFINITION

"""
Adds offset clause to the builder.
"""
directive @paginatedOffset
on
    | ARGUMENT_DEFINITION

"""
Adds offset-based pagination for the relation.
"""
directive @paginatedRelation
on
    | FIELD_DEFINITION

"""
Validate an argument using [Laravel validation](https://laravel.com/docs/validation).
"""
directive @rules(
    """
    Specify the validation rules to apply to the field.
    This can either be a reference to [Laravel's built-in validation rules](https://laravel.com/docs/validation#available-validation-rules),
    or the fully qualified class name of a custom validation rule.

    Rules that mutate the incoming arguments, such as `exclude_if`, are not supported
    by Lighthouse. Use ArgTransformerDirectives or FieldMiddlewareDirectives instead.
    """
    apply: [String!]!

    """
    Specify a custom attribute name to use in your validation message.
    """
    attribute: String

    """
    Specify the messages to return if the validators fail.
    """
    messages: [RulesMessage!]
)
repeatable on
    | ARGUMENT_DEFINITION
    | INPUT_FIELD_DEFINITION

"""
Convert Input into Search Conditions.
"""
directive @searchBy
on
    | ARGUMENT_DEFINITION

"""
Convert Input into Sort Clause.
"""
directive @sortBy
on
    | ARGUMENT_DEFINITION
