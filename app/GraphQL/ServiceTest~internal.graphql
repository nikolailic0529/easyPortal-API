"""
Sort direction.
"""
enum AggregatedGroupByTypeDirection {
    asc
    desc
}

enum CachedMode {
    """
    In this mode all queries will be cached always.
    """
    Normal

    """
    In this mode, the query will be cached only if the execution time is
    greater than the threshold.
    """
    Threshold
}

enum OrganizationType {
    Reseller
}

enum SearchByTypeFlag {
    yes
}

"""
Sort direction.
"""
enum SortByTypeDirection {
    asc
    desc
}

enum Trashed {
    """
    Trashed items will be returned too.
    """
    Include

    """
    Only trashed items will be returned.
    """
    Only
}

"""
Group clause for `input ApplicationLogsQuery` (only one property allowed at a time).
"""
input AggregatedGroupByClauseApplicationLogsQuery {
    """
    Property clause.
    """
    action: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    category: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    object_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    object_type: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    status: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString
}

"""
Group clause for `input AssetsQuery` (only one property allowed at a time).
"""
input AggregatedGroupByClauseAssetsQuery {
    """
    Property clause.
    """
    contacts_active_quantity: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    coverages_count: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Relationship clause.
    """
    customer: [SortByClauseCompaniesSort!]
    @aggregatedGroupByOperatorRelation

    """
    Property clause.
    """
    customer_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Relationship clause.
    """
    location: [SortByClauseLocationsSort!]
    @aggregatedGroupByOperatorRelation

    """
    Property clause.
    """
    location_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    nickname: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Relationship clause.
    """
    oem: [SortByClauseOemsSort!]
    @aggregatedGroupByOperatorRelation

    """
    Property clause.
    """
    oem_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Relationship clause.
    """
    product: [SortByClauseProductsSort!]
    @aggregatedGroupByOperatorRelation

    """
    Property clause.
    """
    product_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Relationship clause.
    """
    reseller: [SortByClauseCompaniesSort!]
    @aggregatedGroupByOperatorRelation

    """
    Property clause.
    """
    reseller_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    serial_number: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Relationship clause.
    """
    status: [SortByClauseStatusesSort!]
    @aggregatedGroupByOperatorRelation

    """
    Property clause.
    """
    status_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Relationship clause.
    """
    type: [SortByClauseTypesSort!]
    @aggregatedGroupByOperatorRelation

    """
    Property clause.
    """
    type_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Relationship clause.
    """
    warrantyServiceGroup: [SortByClauseServiceGroupsSort!]
    @aggregatedGroupByOperatorRelation

    """
    Relationship clause.
    """
    warrantyServiceLevel: [SortByClauseServiceLevelsSort!]
    @aggregatedGroupByOperatorRelation

    """
    Property clause.
    """
    warranty_end: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsDate

    """
    Property clause.
    """
    warranty_service_group_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    warranty_service_level_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString
}

"""
Group clause for `input AuditsQuery` (only one property allowed at a time).
"""
input AggregatedGroupByClauseAuditsQuery {
    """
    Property clause.
    """
    action: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    object_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    object_type: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    organization_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    user_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString
}

"""
Group clause for `input ChangeRequestsQuery` (only one property allowed at a time).
"""
input AggregatedGroupByClauseChangeRequestsQuery {
    """
    Property clause.
    """
    from: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    message: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    subject: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Relationship clause.
    """
    user: [SortByClauseUsersSort!]
    @aggregatedGroupByOperatorRelation

    """
    Property clause.
    """
    user_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString
}

"""
Group clause for `input CompaniesQuery` (only one property allowed at a time).
"""
input AggregatedGroupByClauseCompaniesQuery {
    """
    Property clause.
    """
    contacts_count: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    name: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    statuses_count: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString
}

"""
Group clause for `input CompanyLocationsQuery` (only one property allowed at a time).
"""
input AggregatedGroupByClauseCompanyLocationsQuery {
    """
    Relationship clause.
    """
    location: [SortByClauseLocationsSort!]
    @aggregatedGroupByOperatorRelation

    """
    Property clause.
    """
    location_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString
}

"""
Group clause for `input ContactsQuery` (only one property allowed at a time).
"""
input AggregatedGroupByClauseContactsQuery {
    """
    Property clause.
    """
    name: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString
}

"""
Group clause for `input DistributorsQuery` (only one property allowed at a time).
"""
input AggregatedGroupByClauseDistributorsQuery {
    """
    Property clause.
    """
    name: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString
}

"""
Group clause for `input DocumentEntriesQuery` (only one property allowed at a time).
"""
input AggregatedGroupByClauseDocumentEntriesQuery {
    """
    Relationship clause.
    """
    asset: [SortByClauseAssetsSort!]
    @aggregatedGroupByOperatorRelation

    """
    Relationship clause.
    """
    assetType: [SortByClauseTypesSort!]
    @aggregatedGroupByOperatorRelation

    """
    Property clause.
    """
    asset_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    asset_type_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Relationship clause.
    """
    currency: [SortByClauseCurrenciesSort!]
    @aggregatedGroupByOperatorRelation

    """
    Property clause.
    """
    currency_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    document_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    end: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsDate

    """
    Property clause.
    """
    environment_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    equipment_number: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Relationship clause.
    """
    language: [SortByClauseLanguagesSort!]
    @aggregatedGroupByOperatorRelation

    """
    Property clause.
    """
    language_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    oem_said: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    oem_sar_number: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Relationship clause.
    """
    product: [SortByClauseProductsSort!]
    @aggregatedGroupByOperatorRelation

    """
    Relationship clause.
    """
    productGroup: [SortByClauseProductGroupsSort!]
    @aggregatedGroupByOperatorRelation

    """
    Relationship clause.
    """
    productLine: [SortByClauseProductLinesSort!]
    @aggregatedGroupByOperatorRelation

    """
    Property clause.
    """
    product_group_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    product_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    product_line_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Relationship clause.
    """
    psp: [SortByClausePspsSort!]
    @aggregatedGroupByOperatorRelation

    """
    Property clause.
    """
    psp_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    serial_number: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Relationship clause.
    """
    serviceGroup: [SortByClauseServiceGroupsSort!]
    @aggregatedGroupByOperatorRelation

    """
    Relationship clause.
    """
    serviceLevel: [SortByClauseServiceLevelsSort!]
    @aggregatedGroupByOperatorRelation

    """
    Property clause.
    """
    service_group_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    service_level_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    start: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsDate
}

"""
Group clause for `input DocumentsQuery` (only one property allowed at a time).
"""
input AggregatedGroupByClauseDocumentsQuery {
    """
    Property clause.
    """
    contacts_count: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Relationship clause.
    """
    currency: [SortByClauseCurrenciesSort!]
    @aggregatedGroupByOperatorRelation

    """
    Property clause.
    """
    currency_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Relationship clause.
    """
    customer: [SortByClauseCompaniesSort!]
    @aggregatedGroupByOperatorRelation

    """
    Property clause.
    """
    customer_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Relationship clause.
    """
    distributor: [SortByClauseDistributorsSort!]
    @aggregatedGroupByOperatorRelation

    """
    Property clause.
    """
    distributor_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    end: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsDate

    """
    Property clause.
    """
    entries_count: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Relationship clause.
    """
    language: [SortByClauseLanguagesSort!]
    @aggregatedGroupByOperatorRelation

    """
    Property clause.
    """
    language_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    number: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Relationship clause.
    """
    oem: [SortByClauseOemsSort!]
    @aggregatedGroupByOperatorRelation

    """
    Relationship clause.
    """
    oemGroup: [SortByClauseOemGroupsSort!]
    @aggregatedGroupByOperatorRelation

    """
    Property clause.
    """
    oem_amp_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    oem_group_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    oem_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    oem_said: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    oem_sar_number: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Relationship clause.
    """
    reseller: [SortByClauseCompaniesSort!]
    @aggregatedGroupByOperatorRelation

    """
    Property clause.
    """
    reseller_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    start: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsDate

    """
    Property clause.
    """
    statuses_count: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    type_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString
}

"""
Group clause for `input MeSearchQuery` (only one property allowed at a time).
"""
input AggregatedGroupByClauseMeSearchQuery {
    """
    Property clause.
    """
    key: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    name: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString
}

"""
Group clause for `input NotesQuery` (only one property allowed at a time).
"""
input AggregatedGroupByClauseNotesQuery {
    """
    Relationship clause.
    """
    user: [SortByClauseUsersSort!]
    @aggregatedGroupByOperatorRelation

    """
    Property clause.
    """
    user_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString
}

"""
Group clause for `input OemGroupsQuery` (only one property allowed at a time).
"""
input AggregatedGroupByClauseOemGroupsQuery {
    """
    Property clause.
    """
    key: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    name: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString
}

"""
Group clause for `input OrganizationsQuery` (only one property allowed at a time).
"""
input AggregatedGroupByClauseOrganizationsQuery {
    """
    Property clause.
    """
    name: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString
}

"""
Group clause for `input ProductsQuery` (only one property allowed at a time).
"""
input AggregatedGroupByClauseProductsQuery {
    """
    Property clause.
    """
    name: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Relationship clause.
    """
    oem: [SortByClauseOemsSort!]
    @aggregatedGroupByOperatorRelation

    """
    Property clause.
    """
    oem_id: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    sku: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString
}

"""
Group clause for `input UsersQuery` (only one property allowed at a time).
"""
input AggregatedGroupByClauseUsersQuery {
    """
    Property clause.
    """
    family_name: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString

    """
    Property clause.
    """
    given_name: AggregatedGroupByTypeDirection
    @aggregatedGroupByOperatorAsString
}

input ApplicationMaintenanceScheduleInput {
    end: DateTime!
    message: String
    start: DateTime!
}

input AssetSetNicknameInput {
    nickname: String
    @isNullable
    @isRequired
    @isMax(
        value: 255
    )
}

input AuthOrganizationAuthorizeInput {
    code: String!
    state: String!
}

input AuthSignInInput {
    email: Email!
    @isEmail

    password: String!
}

input AuthSignUpByInviteInput {
    family_name: String!
    given_name: String!
    password: String!
}

input CreateContractNoteInput
@validator(
    class: "App\\GraphQL\\Validators\\CreateContractNoteInputValidator"
)
{
    contract_id: String!
    files: [Upload!]
    note: HtmlString!
    pinned: Boolean
}

input CreateMeSearchInput {
    conditions: String!
    key: String!
    name: String!
}

input CreateQuoteNoteInput
@validator(
    class: "App\\GraphQL\\Validators\\CreateQuoteNoteInputValidator"
)
{
    files: [Upload!]
    note: HtmlString!
    pinned: Boolean
    quote_id: String!
}

input DeleteClientSettingsInput {
    names: [String!]!
}

input DeleteContractNoteInput {
    id: ID!
}

input DeleteMeSearchInput {
    id: ID!
}

input DeleteQuoteNoteInput {
    id: ID!
}

input DispatchApplicationServiceInput {
    """
    If true the service will be executed right now.
    """
    immediately: Boolean! = false

    """
    Name of the service.
    """
    name: String!
}

input LocaleImportInput {
    """
    XLSX file with translation strings. The first row can contains headers
    and will be ignored. The first column is the key, the second - value.
    """
    translations: Upload!
    @isRequired
    @isSpreadsheet
}

input LocaleUpdateInput {
    translations: [LocaleUpdateTranslationInput!]
}

input LocaleUpdateTranslationInput {
    """
    Client translations must use `client.` prefix.
    """
    key: String!
    @isRequired

    """
    If `null` the key will be reset to default value.
    """
    value: String
}

input MeUpdateInput {
    academic_title: String
    @isNullable
    @isRequired
    @isMax(
        value: 255
    )

    contact_email: Email
    @isNullable
    @isMax(
        value: 255
    )
    @isEmail

    family_name: String
    @isRequired
    @isMax(
        value: 255
    )

    given_name: String
    @isRequired
    @isMax(
        value: 255
    )

    homepage: String
    @isNullable
    @isRequired
    @isMax(
        value: 255
    )

    job_title: String
    @isNullable
    @isRequired
    @isMax(
        value: 255
    )

    locale: String
    @isNullable
    @isLocale

    mobile_phone: PhoneNumber
    @isNullable
    @isPhoneNumber

    office_phone: PhoneNumber
    @isNullable
    @isPhoneNumber

    photo: Upload
    @isNullable
    @isImage

    team_id: ID
    @isNullable
    @isTeamId

    timezone: String
    @isNullable
    @isTimezone

    title: String
    @isNullable
    @isRequired
    @isMax(
        value: 7
    )
}

input MessageInput {
    bcc: [Email!]
    @isRequired
    @isEmail
    @isDistinct

    cc: [Email!]
    @isRequired
    @isEmail
    @isDistinct

    files: [Upload!]
    @isRequired
    @isFile

    message: HtmlString!
    @isRequired

    subject: String!
    @isRequired
}

input OemHpeImportInput {
    file: Upload!
    @isSpreadsheet
}

input OrgRoleCreateInput {
    name: String!
    @isRequired

    permissions: [ID!]!
    @isOrgPermissionId
}

input OrgRoleUpdateInput {
    name: String
    @isRequired

    permissions: [ID!]
    @isOrgPermissionId
}

input OrgSetInput {
    organization_id: ID!
    @isOrganizationId
}

input OrgUpdateBrandingInput {
    dark_theme: Boolean
    @isNullable
    @isRequired

    dashboard_image_url: Upload
    @isNullable
    @isImage

    favicon_url: Upload
    @isNullable
    @isImage

    logo_url: Upload
    @isNullable
    @isImage

    main_color: Color
    @isNullable
    @isColor

    secondary_color: Color
    @isNullable
    @isColor

    welcome_heading: [TranslatedStringInput!]

    welcome_image_url: Upload
    @isNullable
    @isImage

    welcome_underline: [TranslatedStringInput!]
}

input OrgUpdateInput {
    analytics_code: String
    @isNullable
    @isRequired

    branding: OrgUpdateBrandingInput

    currency_id: ID
    @isNullable
    @isCurrencyId

    email: Email
    @isNullable
    @isEmail

    locale: String
    @isNullable
    @isLocale

    timezone: String
    @isNullable
    @isTimezone

    website_url: Url
    @isNullable
    @isUrl
}

input OrgUserInviteInput {
    email: Email!
    @isEmail

    role_id: ID!
    @isOrgRoleId

    team_id: ID
    @isNullable
    @isTeamId
}

input OrgUserUpdateInput {
    academic_title: String
    @isNullable
    @isRequired
    @isMax(
        value: 255
    )

    contact_email: Email
    @isNullable
    @isMax(
        value: 255
    )
    @isEmail

    enabled: Boolean
    @isNotMe
    @isRequired

    family_name: String
    @isRequired
    @isMax(
        value: 255
    )

    given_name: String
    @isRequired
    @isMax(
        value: 255
    )

    homepage: String
    @isNullable
    @isRequired
    @isMax(
        value: 255
    )

    job_title: String
    @isNullable
    @isRequired
    @isMax(
        value: 255
    )

    locale: String
    @isNullable
    @isLocale

    mobile_phone: PhoneNumber
    @isNullable
    @isPhoneNumber

    office_phone: PhoneNumber
    @isNullable
    @isPhoneNumber

    photo: Upload
    @isNullable
    @isImage

    role_id: ID
    @isNotMe
    @isRequired
    @isOrgRoleId

    team_id: ID
    @isNullable
    @isTeamId

    timezone: String
    @isNullable
    @isTimezone

    title: String
    @isNullable
    @isRequired
    @isMax(
        value: 7
    )
}

input OrganizationUserInviteInput {
    email: Email!
    @isEmail

    role_id: ID!
    @isOrganizationRoleId

    team_id: ID
    @isNullable
    @isTeamId
}

input QuoteRequestCreateAssetInput {
    asset_id: ID!
    @isRequired
    @isAssetId

    duration_id: ID!
    @isRequired
    @isQuoteRequestDurationId

    service_level_custom: String
    @isRequiredWithout(
        field: "input.assets.*.service_level_id"
    )
    @isProhibitedUnless(
        field: "input.assets.*.service_level_id"
        value: null
    )
    @isNullable
    @isMax(
        value: 255
    )

    service_level_id: ID
    @isRequiredWithout(
        field: "input.assets.*.service_level_custom"
    )
    @isProhibitedUnless(
        field: "input.assets.*.service_level_custom"
        value: null
    )
    @isNullable
    @isServiceLevelId
}

input QuoteRequestCreateDocumentInput {
    document_id: ID!
    @isRequired
    @isDocumentId

    duration_id: ID!
    @isRequired
    @isQuoteRequestDurationId
}

input QuoteRequestCreateInput {
    assets: [QuoteRequestCreateAssetInput!]

    contact_email: Email!
    @isRequired
    @isMax(
        value: 255
    )
    @isEmail

    contact_name: String!
    @isRequired
    @isMax(
        value: 128
    )

    contact_phone: PhoneNumber!
    @isRequired
    @isPhoneNumber

    """
    If `true` the current user will receive a copy.
    """
    copy_to_me: Boolean! = true

    customer_custom: String
    @isRequiredWithout(
        field: "input.customer_id"
    )
    @isProhibitedUnless(
        field: "input.customer_id"
        value: null
    )
    @isNullable
    @isMax(
        value: 255
    )

    customer_id: ID
    @isRequiredWithout(
        field: "input.customer_custom"
    )
    @isProhibitedUnless(
        field: "input.customer_custom"
        value: null
    )
    @isNullable
    @isCustomerId

    documents: [QuoteRequestCreateDocumentInput!]

    files: [Upload!]
    @isRequired
    @isFile

    message: HtmlString
    @isNullable
    @isRequired

    oem_custom: String
    @isRequiredWithout(
        field: "input.oem_id"
    )
    @isProhibitedUnless(
        field: "input.oem_id"
        value: null
    )
    @isNullable
    @isMax(
        value: 255
    )

    oem_id: ID
    @isRequiredWithout(
        field: "input.oem_custom"
    )
    @isProhibitedUnless(
        field: "input.oem_custom"
        value: null
    )
    @isNullable
    @isOemId

    type_custom: String
    @isRequiredWithout(
        field: "input.type_id"
    )
    @isProhibitedUnless(
        field: "input.type_id"
        value: null
    )
    @isNullable
    @isMax(
        value: 255
    )

    type_id: ID
    @isRequiredWithout(
        field: "input.type_custom"
    )
    @isProhibitedUnless(
        field: "input.type_custom"
        value: null
    )
    @isNullable
    @isQuoteTypeId
}

input ResetApplicationServiceInput {
    """
    Name of the service.
    """
    name: String!
}

input ResetOrgUserPasswordInput {
    id: ID!
}

input ResetPasswordInput {
    email: Email!

    password: String!
    @rules(
        apply: ["min:8"]
    )

    token: String!
}

"""
Input for the `messages` argument of `@rules`.
"""
input RulesMessage {
    """
    Message to display if the rule fails, e.g. `"Must be a valid email"`.
    """
    message: String!

    """
    Name of the rule, e.g. `"email"`.
    """
    rule: String!
}

"""
Conditions for the related objects (`has()`/`doesntHave()`) for `input AssetWarrantiesQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByComplexRelationAssetWarrantiesQuery {
    """
    Count conditions.
    """
    count: SearchByScalarInt

    """
    Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used.
    """
    exists: Boolean

    """
    Alias for `count: {lessThan: 1}`. Will be ignored if `count` used.
    """
    notExists: Boolean! = false

    """
    Additional conditions.
    """
    where: SearchByConditionAssetWarrantiesQuery
}

"""
Conditions for the related objects (`has()`/`doesntHave()`) for `input AssetsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByComplexRelationAssetsQuery {
    """
    Count conditions.
    """
    count: SearchByScalarInt

    """
    Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used.
    """
    exists: Boolean

    """
    Alias for `count: {lessThan: 1}`. Will be ignored if `count` used.
    """
    notExists: Boolean! = false

    """
    Additional conditions.
    """
    where: SearchByConditionAssetsQuery
}

"""
Conditions for the related objects (`has()`/`doesntHave()`) for `input CitiesQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByComplexRelationCitiesQuery {
    """
    Count conditions.
    """
    count: SearchByScalarInt

    """
    Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used.
    """
    exists: Boolean

    """
    Alias for `count: {lessThan: 1}`. Will be ignored if `count` used.
    """
    notExists: Boolean! = false

    """
    Additional conditions.
    """
    where: SearchByConditionCitiesQuery
}

"""
Conditions for the related objects (`has()`/`doesntHave()`) for `input CompaniesQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByComplexRelationCompaniesQuery {
    """
    Count conditions.
    """
    count: SearchByScalarInt

    """
    Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used.
    """
    exists: Boolean

    """
    Alias for `count: {lessThan: 1}`. Will be ignored if `count` used.
    """
    notExists: Boolean! = false

    """
    Additional conditions.
    """
    where: SearchByConditionCompaniesQuery
}

"""
Conditions for the related objects (`has()`/`doesntHave()`) for `input CompanyLocationsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByComplexRelationCompanyLocationsQuery {
    """
    Count conditions.
    """
    count: SearchByScalarInt

    """
    Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used.
    """
    exists: Boolean

    """
    Alias for `count: {lessThan: 1}`. Will be ignored if `count` used.
    """
    notExists: Boolean! = false

    """
    Additional conditions.
    """
    where: SearchByConditionCompanyLocationsQuery
}

"""
Conditions for the related objects (`has()`/`doesntHave()`) for `input ContactsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByComplexRelationContactsQuery {
    """
    Count conditions.
    """
    count: SearchByScalarInt

    """
    Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used.
    """
    exists: Boolean

    """
    Alias for `count: {lessThan: 1}`. Will be ignored if `count` used.
    """
    notExists: Boolean! = false

    """
    Additional conditions.
    """
    where: SearchByConditionContactsQuery
}

"""
Conditions for the related objects (`has()`/`doesntHave()`) for `input CountriesQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByComplexRelationCountriesQuery {
    """
    Count conditions.
    """
    count: SearchByScalarInt

    """
    Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used.
    """
    exists: Boolean

    """
    Alias for `count: {lessThan: 1}`. Will be ignored if `count` used.
    """
    notExists: Boolean! = false

    """
    Additional conditions.
    """
    where: SearchByConditionCountriesQuery
}

"""
Conditions for the related objects (`has()`/`doesntHave()`) for `input CoveragesQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByComplexRelationCoveragesQuery {
    """
    Count conditions.
    """
    count: SearchByScalarInt

    """
    Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used.
    """
    exists: Boolean

    """
    Alias for `count: {lessThan: 1}`. Will be ignored if `count` used.
    """
    notExists: Boolean! = false

    """
    Additional conditions.
    """
    where: SearchByConditionCoveragesQuery
}

"""
Conditions for the related objects (`has()`/`doesntHave()`) for `input CurrenciesQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByComplexRelationCurrenciesQuery {
    """
    Count conditions.
    """
    count: SearchByScalarInt

    """
    Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used.
    """
    exists: Boolean

    """
    Alias for `count: {lessThan: 1}`. Will be ignored if `count` used.
    """
    notExists: Boolean! = false

    """
    Additional conditions.
    """
    where: SearchByConditionCurrenciesQuery
}

"""
Conditions for the related objects (`has()`/`doesntHave()`) for `input DistributorsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByComplexRelationDistributorsQuery {
    """
    Count conditions.
    """
    count: SearchByScalarInt

    """
    Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used.
    """
    exists: Boolean

    """
    Alias for `count: {lessThan: 1}`. Will be ignored if `count` used.
    """
    notExists: Boolean! = false

    """
    Additional conditions.
    """
    where: SearchByConditionDistributorsQuery
}

"""
Conditions for the related objects (`has()`/`doesntHave()`) for `input DocumentEntriesQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByComplexRelationDocumentEntriesQuery {
    """
    Count conditions.
    """
    count: SearchByScalarInt

    """
    Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used.
    """
    exists: Boolean

    """
    Alias for `count: {lessThan: 1}`. Will be ignored if `count` used.
    """
    notExists: Boolean! = false

    """
    Additional conditions.
    """
    where: SearchByConditionDocumentEntriesQuery
}

"""
Conditions for the related objects (`has()`/`doesntHave()`) for `input DocumentsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByComplexRelationDocumentsQuery {
    """
    Count conditions.
    """
    count: SearchByScalarInt

    """
    Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used.
    """
    exists: Boolean

    """
    Alias for `count: {lessThan: 1}`. Will be ignored if `count` used.
    """
    notExists: Boolean! = false

    """
    Additional conditions.
    """
    where: SearchByConditionDocumentsQuery
}

"""
Conditions for the related objects (`has()`/`doesntHave()`) for `input LanguagesQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByComplexRelationLanguagesQuery {
    """
    Count conditions.
    """
    count: SearchByScalarInt

    """
    Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used.
    """
    exists: Boolean

    """
    Alias for `count: {lessThan: 1}`. Will be ignored if `count` used.
    """
    notExists: Boolean! = false

    """
    Additional conditions.
    """
    where: SearchByConditionLanguagesQuery
}

"""
Conditions for the related objects (`has()`/`doesntHave()`) for `input LocationsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByComplexRelationLocationsQuery {
    """
    Count conditions.
    """
    count: SearchByScalarInt

    """
    Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used.
    """
    exists: Boolean

    """
    Alias for `count: {lessThan: 1}`. Will be ignored if `count` used.
    """
    notExists: Boolean! = false

    """
    Additional conditions.
    """
    where: SearchByConditionLocationsQuery
}

"""
Conditions for the related objects (`has()`/`doesntHave()`) for `input OemGroupsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByComplexRelationOemGroupsQuery {
    """
    Count conditions.
    """
    count: SearchByScalarInt

    """
    Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used.
    """
    exists: Boolean

    """
    Alias for `count: {lessThan: 1}`. Will be ignored if `count` used.
    """
    notExists: Boolean! = false

    """
    Additional conditions.
    """
    where: SearchByConditionOemGroupsQuery
}

"""
Conditions for the related objects (`has()`/`doesntHave()`) for `input OemsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByComplexRelationOemsQuery {
    """
    Count conditions.
    """
    count: SearchByScalarInt

    """
    Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used.
    """
    exists: Boolean

    """
    Alias for `count: {lessThan: 1}`. Will be ignored if `count` used.
    """
    notExists: Boolean! = false

    """
    Additional conditions.
    """
    where: SearchByConditionOemsQuery
}

"""
Conditions for the related objects (`has()`/`doesntHave()`) for `input OrganizationsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByComplexRelationOrganizationsQuery {
    """
    Count conditions.
    """
    count: SearchByScalarInt

    """
    Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used.
    """
    exists: Boolean

    """
    Alias for `count: {lessThan: 1}`. Will be ignored if `count` used.
    """
    notExists: Boolean! = false

    """
    Additional conditions.
    """
    where: SearchByConditionOrganizationsQuery
}

"""
Conditions for the related objects (`has()`/`doesntHave()`) for `input ProductGroupsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByComplexRelationProductGroupsQuery {
    """
    Count conditions.
    """
    count: SearchByScalarInt

    """
    Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used.
    """
    exists: Boolean

    """
    Alias for `count: {lessThan: 1}`. Will be ignored if `count` used.
    """
    notExists: Boolean! = false

    """
    Additional conditions.
    """
    where: SearchByConditionProductGroupsQuery
}

"""
Conditions for the related objects (`has()`/`doesntHave()`) for `input ProductLinesQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByComplexRelationProductLinesQuery {
    """
    Count conditions.
    """
    count: SearchByScalarInt

    """
    Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used.
    """
    exists: Boolean

    """
    Alias for `count: {lessThan: 1}`. Will be ignored if `count` used.
    """
    notExists: Boolean! = false

    """
    Additional conditions.
    """
    where: SearchByConditionProductLinesQuery
}

"""
Conditions for the related objects (`has()`/`doesntHave()`) for `input ProductsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByComplexRelationProductsQuery {
    """
    Count conditions.
    """
    count: SearchByScalarInt

    """
    Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used.
    """
    exists: Boolean

    """
    Alias for `count: {lessThan: 1}`. Will be ignored if `count` used.
    """
    notExists: Boolean! = false

    """
    Additional conditions.
    """
    where: SearchByConditionProductsQuery
}

"""
Conditions for the related objects (`has()`/`doesntHave()`) for `input PspsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByComplexRelationPspsQuery {
    """
    Count conditions.
    """
    count: SearchByScalarInt

    """
    Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used.
    """
    exists: Boolean

    """
    Alias for `count: {lessThan: 1}`. Will be ignored if `count` used.
    """
    notExists: Boolean! = false

    """
    Additional conditions.
    """
    where: SearchByConditionPspsQuery
}

"""
Conditions for the related objects (`has()`/`doesntHave()`) for `input ServiceGroupsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByComplexRelationServiceGroupsQuery {
    """
    Count conditions.
    """
    count: SearchByScalarInt

    """
    Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used.
    """
    exists: Boolean

    """
    Alias for `count: {lessThan: 1}`. Will be ignored if `count` used.
    """
    notExists: Boolean! = false

    """
    Additional conditions.
    """
    where: SearchByConditionServiceGroupsQuery
}

"""
Conditions for the related objects (`has()`/`doesntHave()`) for `input ServiceLevelsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByComplexRelationServiceLevelsQuery {
    """
    Count conditions.
    """
    count: SearchByScalarInt

    """
    Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used.
    """
    exists: Boolean

    """
    Alias for `count: {lessThan: 1}`. Will be ignored if `count` used.
    """
    notExists: Boolean! = false

    """
    Additional conditions.
    """
    where: SearchByConditionServiceLevelsQuery
}

"""
Conditions for the related objects (`has()`/`doesntHave()`) for `input StatusesQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByComplexRelationStatusesQuery {
    """
    Count conditions.
    """
    count: SearchByScalarInt

    """
    Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used.
    """
    exists: Boolean

    """
    Alias for `count: {lessThan: 1}`. Will be ignored if `count` used.
    """
    notExists: Boolean! = false

    """
    Additional conditions.
    """
    where: SearchByConditionStatusesQuery
}

"""
Conditions for the related objects (`has()`/`doesntHave()`) for `input TagsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByComplexRelationTagsQuery {
    """
    Count conditions.
    """
    count: SearchByScalarInt

    """
    Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used.
    """
    exists: Boolean

    """
    Alias for `count: {lessThan: 1}`. Will be ignored if `count` used.
    """
    notExists: Boolean! = false

    """
    Additional conditions.
    """
    where: SearchByConditionTagsQuery
}

"""
Conditions for the related objects (`has()`/`doesntHave()`) for `input TypesQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByComplexRelationTypesQuery {
    """
    Count conditions.
    """
    count: SearchByScalarInt

    """
    Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used.
    """
    exists: Boolean

    """
    Alias for `count: {lessThan: 1}`. Will be ignored if `count` used.
    """
    notExists: Boolean! = false

    """
    Additional conditions.
    """
    where: SearchByConditionTypesQuery
}

"""
Conditions for the related objects (`has()`/`doesntHave()`) for `input UsersQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByComplexRelationUsersQuery {
    """
    Count conditions.
    """
    count: SearchByScalarInt

    """
    Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used.
    """
    exists: Boolean

    """
    Alias for `count: {lessThan: 1}`. Will be ignored if `count` used.
    """
    notExists: Boolean! = false

    """
    Additional conditions.
    """
    where: SearchByConditionUsersQuery
}

"""
Available conditions for `input ApplicationLogsQuery` (only one property allowed at a time).
"""
input SearchByConditionApplicationLogsQuery {
    """
    Property condition.
    """
    action: SearchByScalarString
    @searchByProperty

    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionApplicationLogsQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionApplicationLogsQuery!]
    @searchByOperatorAnyOf

    """
    Property condition.
    """
    category: SearchByScalarString
    @searchByProperty

    """
    Property condition.
    """
    created_at: SearchByScalarDateTime
    @searchByProperty

    """
    Property condition.
    """
    duration: SearchByScalarFloatOrNull
    @searchByProperty

    """
    Property condition.
    """
    finished_at: SearchByScalarDateTimeOrNull
    @searchByProperty

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionApplicationLogsQuery
    @searchByOperatorNot

    """
    Property condition.
    """
    object_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Property condition.
    """
    object_type: SearchByScalarStringOrNull
    @searchByProperty

    """
    Property condition.
    """
    status: SearchByScalarStringOrNull
    @searchByProperty
}

"""
Available conditions for `input AssetCoveragesQuery` (only one property allowed at a time).
"""
input SearchByConditionAssetCoveragesQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionAssetCoveragesQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionAssetCoveragesQuery!]
    @searchByOperatorAnyOf

    """
    Relationship condition.
    """
    assets: SearchByComplexRelationAssetsQuery
    @searchByOperatorRelation

    """
    Not.
    """
    not: SearchByConditionAssetCoveragesQuery
    @searchByOperatorNot
}

"""
Available conditions for `input AssetStatusesQuery` (only one property allowed at a time).
"""
input SearchByConditionAssetStatusesQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionAssetStatusesQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionAssetStatusesQuery!]
    @searchByOperatorAnyOf

    """
    Relationship condition.
    """
    assets: SearchByComplexRelationAssetsQuery
    @searchByOperatorRelation

    """
    Not.
    """
    not: SearchByConditionAssetStatusesQuery
    @searchByOperatorNot
}

"""
Available conditions for `input AssetTypesQuery` (only one property allowed at a time).
"""
input SearchByConditionAssetTypesQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionAssetTypesQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionAssetTypesQuery!]
    @searchByOperatorAnyOf

    """
    Relationship condition.
    """
    assets: SearchByComplexRelationAssetsQuery
    @searchByOperatorRelation

    """
    Not.
    """
    not: SearchByConditionAssetTypesQuery
    @searchByOperatorNot
}

"""
Available conditions for `input AssetWarrantiesQuery` (only one property allowed at a time).
"""
input SearchByConditionAssetWarrantiesQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionAssetWarrantiesQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionAssetWarrantiesQuery!]
    @searchByOperatorAnyOf

    """
    Relationship condition.
    """
    asset: SearchByComplexRelationAssetsQuery
    @searchByOperatorRelation

    """
    Relationship condition.
    """
    customer: SearchByComplexRelationCompaniesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    customer_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Relationship condition.
    """
    document: SearchByComplexRelationDocumentsQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    document_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Property condition.
    """
    document_number: SearchByScalarStringOrNull
    @searchByProperty

    """
    Property condition.
    """
    end: SearchByScalarDateOrNull
    @searchByProperty

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionAssetWarrantiesQuery
    @searchByOperatorNot

    """
    Relationship condition.
    """
    reseller: SearchByComplexRelationCompaniesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    reseller_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Property condition.
    """
    service_group_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Property condition.
    """
    service_level_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Property condition.
    """
    start: SearchByScalarDateOrNull
    @searchByProperty
}

"""
Available conditions for `input AssetsQuery` (only one property allowed at a time).
"""
input SearchByConditionAssetsQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionAssetsQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionAssetsQuery!]
    @searchByOperatorAnyOf

    """
    Property condition.
    """
    contacts_active_quantity: SearchByScalarIntOrNull
    @searchByProperty

    """
    Relationship condition.
    """
    contracts: SearchByComplexRelationDocumentsQuery
    @searchByOperatorRelation

    """
    Relationship condition.
    """
    coverages: SearchByComplexRelationCoveragesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    coverages_count: SearchByScalarInt
    @searchByProperty

    """
    Relationship condition.
    """
    customer: SearchByComplexRelationCompaniesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    customer_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Relationship condition.
    """
    location: SearchByComplexRelationLocationsQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    location_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Property condition.
    """
    nickname: SearchByScalarStringOrNull
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionAssetsQuery
    @searchByOperatorNot

    """
    Relationship condition.
    """
    oem: SearchByComplexRelationOemsQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    oem_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Relationship condition.
    """
    product: SearchByComplexRelationProductsQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    product_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Relationship condition.
    """
    quotes: SearchByComplexRelationDocumentsQuery
    @searchByOperatorRelation

    """
    Relationship condition.
    """
    reseller: SearchByComplexRelationCompaniesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    reseller_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Property condition.
    """
    serial_number: SearchByScalarStringOrNull
    @searchByProperty

    """
    Relationship condition.
    """
    status: SearchByComplexRelationStatusesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    status_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Relationship condition.
    """
    tags: SearchByComplexRelationTagsQuery
    @searchByOperatorRelation

    """
    Relationship condition.
    """
    type: SearchByComplexRelationTypesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    type_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Relationship condition.
    """
    warranties: SearchByComplexRelationAssetWarrantiesQuery
    @searchByOperatorRelation

    """
    Relationship condition.
    """
    warrantyServiceGroup: SearchByComplexRelationServiceGroupsQuery
    @searchByOperatorRelation

    """
    Relationship condition.
    """
    warrantyServiceLevel: SearchByComplexRelationServiceLevelsQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    warranty_end: SearchByScalarDateOrNull
    @searchByProperty

    """
    Property condition.
    """
    warranty_service_group_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Property condition.
    """
    warranty_service_level_id: SearchByScalarIDOrNull
    @searchByProperty
}

"""
Available conditions for `input AuditsQuery` (only one property allowed at a time).
"""
input SearchByConditionAuditsQuery {
    """
    Property condition.
    """
    action: SearchByScalarString
    @searchByProperty

    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionAuditsQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionAuditsQuery!]
    @searchByOperatorAnyOf

    """
    Property condition.
    """
    created_at: SearchByScalarDateTime
    @searchByProperty

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionAuditsQuery
    @searchByOperatorNot

    """
    Property condition.
    """
    object_id: SearchByScalarString
    @searchByProperty

    """
    Property condition.
    """
    object_type: SearchByScalarString
    @searchByProperty

    """
    Relationship condition.
    """
    organization: SearchByComplexRelationOrganizationsQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    organization_id: SearchByScalarID
    @searchByProperty

    """
    Property condition.
    """
    updated_at: SearchByScalarDateTime
    @searchByProperty

    """
    Relationship condition.
    """
    user: SearchByComplexRelationUsersQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    user_id: SearchByScalarString
    @searchByProperty
}

"""
Available conditions for `input ChangeRequestsQuery` (only one property allowed at a time).
"""
input SearchByConditionChangeRequestsQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionChangeRequestsQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionChangeRequestsQuery!]
    @searchByOperatorAnyOf

    """
    Property condition.
    """
    from: SearchByScalarString
    @searchByProperty

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Property condition.
    """
    message: SearchByScalarString
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionChangeRequestsQuery
    @searchByOperatorNot

    """
    Property condition.
    """
    subject: SearchByScalarString
    @searchByProperty

    """
    Relationship condition.
    """
    user: SearchByComplexRelationUsersQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    user_id: SearchByScalarID
    @searchByProperty
}

"""
Available conditions for `input CitiesQuery` (only one property allowed at a time).
"""
input SearchByConditionCitiesQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionCitiesQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionCitiesQuery!]
    @searchByOperatorAnyOf

    """
    Relationship condition.
    """
    assets: SearchByComplexRelationAssetsQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    country_id: SearchByScalarID
    @searchByProperty

    """
    Relationship condition.
    """
    customers: SearchByComplexRelationCompaniesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Property condition.
    """
    name: SearchByScalarString
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionCitiesQuery
    @searchByOperatorNot
}

"""
Available conditions for `input CompaniesQuery` (only one property allowed at a time).
"""
input SearchByConditionCompaniesQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionCompaniesQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionCompaniesQuery!]
    @searchByOperatorAnyOf

    """
    Relationship condition.
    """
    assets: SearchByComplexRelationAssetsQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    assets_count: SearchByScalarInt
    @searchByProperty

    """
    Relationship condition.
    """
    contacts: SearchByComplexRelationContactsQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    contacts_count: SearchByScalarInt
    @searchByProperty

    """
    Relationship condition.
    """
    contracts: SearchByComplexRelationDocumentsQuery
    @searchByOperatorRelation

    """
    Relationship condition.
    """
    headquarter: SearchByComplexRelationCompanyLocationsQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Relationship condition.
    """
    locations: SearchByComplexRelationCompanyLocationsQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    locations_count: SearchByScalarInt
    @searchByProperty

    """
    Property condition.
    """
    name: SearchByScalarString
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionCompaniesQuery
    @searchByOperatorNot

    """
    Relationship condition.
    """
    quotes: SearchByComplexRelationDocumentsQuery
    @searchByOperatorRelation

    """
    Relationship condition.
    """
    statuses: SearchByComplexRelationStatusesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    statuses_count: SearchByScalarInt
    @searchByProperty
}

"""
Available conditions for `input CompanyLocationsQuery` (only one property allowed at a time).
"""
input SearchByConditionCompanyLocationsQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionCompanyLocationsQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionCompanyLocationsQuery!]
    @searchByOperatorAnyOf

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Relationship condition.
    """
    location: SearchByComplexRelationLocationsQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    location_id: SearchByScalarID
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionCompanyLocationsQuery
    @searchByOperatorNot

    """
    Relationship condition.
    """
    types: SearchByComplexRelationTypesQuery
    @searchByOperatorRelation
}

"""
Available conditions for `input ContactTypesQuery` (only one property allowed at a time).
"""
input SearchByConditionContactTypesQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionContactTypesQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionContactTypesQuery!]
    @searchByOperatorAnyOf

    """
    Relationship condition.
    """
    contacts: SearchByComplexRelationContactsQuery
    @searchByOperatorRelation

    """
    Not.
    """
    not: SearchByConditionContactTypesQuery
    @searchByOperatorNot
}

"""
Available conditions for `input ContactsQuery` (only one property allowed at a time).
"""
input SearchByConditionContactsQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionContactsQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionContactsQuery!]
    @searchByOperatorAnyOf

    """
    Property condition.
    """
    email: SearchByScalarEmailOrNull
    @searchByProperty

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Property condition.
    """
    name: SearchByScalarStringOrNull
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionContactsQuery
    @searchByOperatorNot

    """
    Property condition.
    """
    phone_number: SearchByScalarPhoneNumberOrNull
    @searchByProperty

    """
    Property condition.
    """
    phone_valid: SearchByScalarBooleanOrNull
    @searchByProperty

    """
    Relationship condition.
    """
    types: SearchByComplexRelationTypesQuery
    @searchByOperatorRelation
}

"""
Available conditions for `input ContractStatusesQuery` (only one property allowed at a time).
"""
input SearchByConditionContractStatusesQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionContractStatusesQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionContractStatusesQuery!]
    @searchByOperatorAnyOf

    """
    Relationship condition.
    """
    contracts: SearchByComplexRelationDocumentsQuery
    @searchByOperatorRelation

    """
    Not.
    """
    not: SearchByConditionContractStatusesQuery
    @searchByOperatorNot
}

"""
Available conditions for `input ContractTypesQuery` (only one property allowed at a time).
"""
input SearchByConditionContractTypesQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionContractTypesQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionContractTypesQuery!]
    @searchByOperatorAnyOf

    """
    Relationship condition.
    """
    contracts: SearchByComplexRelationDocumentsQuery
    @searchByOperatorRelation

    """
    Not.
    """
    not: SearchByConditionContractTypesQuery
    @searchByOperatorNot
}

"""
Available conditions for `input CountriesQuery` (only one property allowed at a time).
"""
input SearchByConditionCountriesQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionCountriesQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionCountriesQuery!]
    @searchByOperatorAnyOf

    """
    Relationship condition.
    """
    assets: SearchByComplexRelationAssetsQuery
    @searchByOperatorRelation

    """
    Relationship condition.
    """
    cities: SearchByComplexRelationCitiesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    code: SearchByScalarString
    @searchByProperty

    """
    Relationship condition.
    """
    customers: SearchByComplexRelationCompaniesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Property condition.
    """
    name: SearchByScalarString
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionCountriesQuery
    @searchByOperatorNot
}

"""
Available conditions for `input CoveragesQuery` (only one property allowed at a time).
"""
input SearchByConditionCoveragesQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionCoveragesQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionCoveragesQuery!]
    @searchByOperatorAnyOf

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionCoveragesQuery
    @searchByOperatorNot
}

"""
Available conditions for `input CurrenciesQuery` (only one property allowed at a time).
"""
input SearchByConditionCurrenciesQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionCurrenciesQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionCurrenciesQuery!]
    @searchByOperatorAnyOf

    """
    Relationship condition.
    """
    documents: SearchByComplexRelationDocumentsQuery
    @searchByOperatorRelation

    """
    Not.
    """
    not: SearchByConditionCurrenciesQuery
    @searchByOperatorNot
}

"""
Available conditions for `input CustomerLocationTypesQuery` (only one property allowed at a time).
"""
input SearchByConditionCustomerLocationTypesQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionCustomerLocationTypesQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionCustomerLocationTypesQuery!]
    @searchByOperatorAnyOf

    """
    Relationship condition.
    """
    customerLocations: SearchByComplexRelationCompanyLocationsQuery
    @searchByOperatorRelation

    """
    Not.
    """
    not: SearchByConditionCustomerLocationTypesQuery
    @searchByOperatorNot
}

"""
Available conditions for `input CustomerStatusesQuery` (only one property allowed at a time).
"""
input SearchByConditionCustomerStatusesQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionCustomerStatusesQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionCustomerStatusesQuery!]
    @searchByOperatorAnyOf

    """
    Relationship condition.
    """
    customers: SearchByComplexRelationCompaniesQuery
    @searchByOperatorRelation

    """
    Not.
    """
    not: SearchByConditionCustomerStatusesQuery
    @searchByOperatorNot
}

"""
Available conditions for `input DistributorsQuery` (only one property allowed at a time).
"""
input SearchByConditionDistributorsQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionDistributorsQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionDistributorsQuery!]
    @searchByOperatorAnyOf

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Property condition.
    """
    name: SearchByScalarString
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionDistributorsQuery
    @searchByOperatorNot
}

"""
Available conditions for `input DocumentEntriesQuery` (only one property allowed at a time).
"""
input SearchByConditionDocumentEntriesQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionDocumentEntriesQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionDocumentEntriesQuery!]
    @searchByOperatorAnyOf

    """
    Relationship condition.
    """
    asset: SearchByComplexRelationAssetsQuery
    @searchByOperatorRelation

    """
    Relationship condition.
    """
    assetType: SearchByComplexRelationTypesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    asset_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Property condition.
    """
    asset_type_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Relationship condition.
    """
    currency: SearchByComplexRelationCurrenciesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    currency_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Property condition.
    """
    document_id: SearchByScalarID
    @searchByProperty

    """
    Property condition.
    """
    end: SearchByScalarDateOrNull
    @searchByProperty

    """
    Property condition.
    """
    environment_id: SearchByScalarStringOrNull
    @searchByProperty

    """
    Property condition.
    """
    equipment_number: SearchByScalarStringOrNull
    @searchByProperty

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Relationship condition.
    """
    language: SearchByComplexRelationLanguagesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    language_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Property condition.
    """
    list_price: SearchByScalarFloatOrNull
    @searchByProperty

    """
    Property condition.
    """
    monthly_list_price: SearchByScalarFloatOrNull
    @searchByProperty

    """
    Property condition.
    """
    monthly_retail_price: SearchByScalarFloatOrNull
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionDocumentEntriesQuery
    @searchByOperatorNot

    """
    Property condition.
    """
    oem_said: SearchByScalarStringOrNull
    @searchByProperty

    """
    Property condition.
    """
    oem_sar_number: SearchByScalarStringOrNull
    @searchByProperty

    """
    Relationship condition.
    """
    product: SearchByComplexRelationProductsQuery
    @searchByOperatorRelation

    """
    Relationship condition.
    """
    productGroup: SearchByComplexRelationProductGroupsQuery
    @searchByOperatorRelation

    """
    Relationship condition.
    """
    productLine: SearchByComplexRelationProductLinesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    product_group_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Property condition.
    """
    product_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Property condition.
    """
    product_line_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Relationship condition.
    """
    psp: SearchByComplexRelationPspsQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    psp_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Property condition.
    """
    renewal: SearchByScalarFloatOrNull
    @searchByProperty

    """
    Property condition.
    """
    serial_number: SearchByScalarStringOrNull
    @searchByProperty

    """
    Relationship condition.
    """
    serviceGroup: SearchByComplexRelationServiceGroupsQuery
    @searchByOperatorRelation

    """
    Relationship condition.
    """
    serviceLevel: SearchByComplexRelationServiceLevelsQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    service_group_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Property condition.
    """
    service_level_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Property condition.
    """
    start: SearchByScalarDateOrNull
    @searchByProperty
}

"""
Available conditions for `input DocumentsQuery` (only one property allowed at a time).
"""
input SearchByConditionDocumentsQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionDocumentsQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionDocumentsQuery!]
    @searchByOperatorAnyOf

    """
    Relationship condition.
    """
    assets: SearchByComplexRelationAssetsQuery
    @searchByOperatorRelation

    """
    Relationship condition.
    """
    contacts: SearchByComplexRelationContactsQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    contacts_count: SearchByScalarInt
    @searchByProperty

    """
    Relationship condition.
    """
    currency: SearchByComplexRelationCurrenciesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    currency_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Relationship condition.
    """
    customer: SearchByComplexRelationCompaniesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    customer_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Relationship condition.
    """
    distributor: SearchByComplexRelationDistributorsQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    distributor_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Property condition.
    """
    end: SearchByScalarDate
    @searchByProperty

    """
    Relationship condition.
    """
    entries: SearchByComplexRelationDocumentEntriesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    entries_count: SearchByScalarInt
    @searchByProperty

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Relationship condition.
    """
    language: SearchByComplexRelationLanguagesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    language_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionDocumentsQuery
    @searchByOperatorNot

    """
    Property condition.
    """
    number: SearchByScalarStringOrNull
    @searchByProperty

    """
    Relationship condition.
    """
    oem: SearchByComplexRelationOemsQuery
    @searchByOperatorRelation

    """
    Relationship condition.
    """
    oemGroup: SearchByComplexRelationOemGroupsQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    oem_amp_id: SearchByScalarStringOrNull
    @searchByProperty

    """
    Property condition.
    """
    oem_group_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Property condition.
    """
    oem_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Property condition.
    """
    oem_said: SearchByScalarStringOrNull
    @searchByProperty

    """
    Property condition.
    """
    oem_sar_number: SearchByScalarStringOrNull
    @searchByProperty

    """
    Relationship condition.
    """
    reseller: SearchByComplexRelationCompaniesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    reseller_id: SearchByScalarIDOrNull
    @searchByProperty

    """
    Property condition.
    """
    start: SearchByScalarDate
    @searchByProperty

    """
    Relationship condition.
    """
    statuses: SearchByComplexRelationStatusesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    statuses_count: SearchByScalarInt
    @searchByProperty

    """
    Property condition.
    """
    type_id: SearchByScalarIDOrNull
    @searchByProperty
}

"""
Available conditions for `input LanguagesQuery` (only one property allowed at a time).
"""
input SearchByConditionLanguagesQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionLanguagesQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionLanguagesQuery!]
    @searchByOperatorAnyOf

    """
    Relationship condition.
    """
    documents: SearchByComplexRelationDocumentsQuery
    @searchByOperatorRelation

    """
    Not.
    """
    not: SearchByConditionLanguagesQuery
    @searchByOperatorNot
}

"""
Available conditions for `input LocationsQuery` (only one property allowed at a time).
"""
input SearchByConditionLocationsQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionLocationsQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionLocationsQuery!]
    @searchByOperatorAnyOf

    """
    Relationship condition.
    """
    assets: SearchByComplexRelationAssetsQuery
    @searchByOperatorRelation

    """
    Relationship condition.
    """
    city: SearchByComplexRelationCitiesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    city_id: SearchByScalarID
    @searchByProperty

    """
    Relationship condition.
    """
    country: SearchByComplexRelationCountriesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    country_id: SearchByScalarID
    @searchByProperty

    """
    Relationship condition.
    """
    customers: SearchByComplexRelationCompaniesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Property condition.
    """
    latitude: SearchByScalarFloatOrNull
    @searchByProperty

    """
    Property condition.
    """
    line_one: SearchByScalarString
    @searchByProperty

    """
    Property condition.
    """
    line_two: SearchByScalarString
    @searchByProperty

    """
    Property condition.
    """
    longitude: SearchByScalarFloatOrNull
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionLocationsQuery
    @searchByOperatorNot

    """
    Property condition.
    """
    postcode: SearchByScalarString
    @searchByProperty

    """
    Property condition.
    """
    state: SearchByScalarString
    @searchByProperty
}

"""
Available conditions for `input MapQuery` (only one property allowed at a time).
"""
input SearchByConditionMapQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionMapQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionMapQuery!]
    @searchByOperatorAnyOf

    """
    Relationship condition.
    """
    city: SearchByComplexRelationCitiesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    city_id: SearchByScalarID
    @searchByProperty

    """
    Relationship condition.
    """
    country: SearchByComplexRelationCountriesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    country_id: SearchByScalarID
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionMapQuery
    @searchByOperatorNot

    """
    Property condition.
    """
    postcode: SearchByScalarString
    @searchByProperty

    """
    Property condition.
    """
    state: SearchByScalarString
    @searchByProperty
}

"""
Available conditions for `input MeSearchQuery` (only one property allowed at a time).
"""
input SearchByConditionMeSearchQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionMeSearchQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionMeSearchQuery!]
    @searchByOperatorAnyOf

    """
    Property condition.
    """
    created_at: SearchByScalarDateTime
    @searchByProperty

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Property condition.
    """
    key: SearchByScalarString
    @searchByProperty

    """
    Property condition.
    """
    name: SearchByScalarString
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionMeSearchQuery
    @searchByOperatorNot
}

"""
Available conditions for `input NotesQuery` (only one property allowed at a time).
"""
input SearchByConditionNotesQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionNotesQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionNotesQuery!]
    @searchByOperatorAnyOf

    """
    Not.
    """
    not: SearchByConditionNotesQuery
    @searchByOperatorNot

    """
    Property condition.
    """
    note: SearchByScalarHtmlStringOrNull
    @searchByProperty

    """
    Property condition.
    """
    pinned: SearchByScalarBoolean
    @searchByProperty

    """
    Relationship condition.
    """
    user: SearchByComplexRelationUsersQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    user_id: SearchByScalarID
    @searchByProperty
}

"""
Available conditions for `input OemGroupsQuery` (only one property allowed at a time).
"""
input SearchByConditionOemGroupsQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionOemGroupsQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionOemGroupsQuery!]
    @searchByOperatorAnyOf

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Property condition.
    """
    key: SearchByScalarString
    @searchByProperty

    """
    Property condition.
    """
    name: SearchByScalarString
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionOemGroupsQuery
    @searchByOperatorNot
}

"""
Available conditions for `input OemsQuery` (only one property allowed at a time).
"""
input SearchByConditionOemsQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionOemsQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionOemsQuery!]
    @searchByOperatorAnyOf

    """
    Relationship condition.
    """
    assets: SearchByComplexRelationAssetsQuery
    @searchByOperatorRelation

    """
    Relationship condition.
    """
    documents: SearchByComplexRelationDocumentsQuery
    @searchByOperatorRelation

    """
    Not.
    """
    not: SearchByConditionOemsQuery
    @searchByOperatorNot
}

"""
Available conditions for `input OrganizationsQuery` (only one property allowed at a time).
"""
input SearchByConditionOrganizationsQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionOrganizationsQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionOrganizationsQuery!]
    @searchByOperatorAnyOf

    """
    Relationship condition.
    """
    company: SearchByComplexRelationCompaniesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    email: SearchByScalarEmailOrNull
    @searchByProperty

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Property condition.
    """
    name: SearchByScalarString
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionOrganizationsQuery
    @searchByOperatorNot

    """
    Property condition.
    """
    type: SearchByEnumOrganizationType
    @searchByProperty

    """
    Property condition.
    """
    website_url: SearchByScalarUrlOrNull
    @searchByProperty
}

"""
Available conditions for `input ProductGroupsQuery` (only one property allowed at a time).
"""
input SearchByConditionProductGroupsQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionProductGroupsQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionProductGroupsQuery!]
    @searchByOperatorAnyOf

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Property condition.
    """
    key: SearchByScalarString
    @searchByProperty

    """
    Property condition.
    """
    name: SearchByScalarString
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionProductGroupsQuery
    @searchByOperatorNot
}

"""
Available conditions for `input ProductLinesQuery` (only one property allowed at a time).
"""
input SearchByConditionProductLinesQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionProductLinesQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionProductLinesQuery!]
    @searchByOperatorAnyOf

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Property condition.
    """
    key: SearchByScalarString
    @searchByProperty

    """
    Property condition.
    """
    name: SearchByScalarString
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionProductLinesQuery
    @searchByOperatorNot
}

"""
Available conditions for `input ProductsQuery` (only one property allowed at a time).
"""
input SearchByConditionProductsQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionProductsQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionProductsQuery!]
    @searchByOperatorAnyOf

    """
    Relationship condition.
    """
    assets: SearchByComplexRelationAssetsQuery
    @searchByOperatorRelation

    """
    Relationship condition.
    """
    documentEntries: SearchByComplexRelationDocumentEntriesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Property condition.
    """
    name: SearchByScalarString
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionProductsQuery
    @searchByOperatorNot

    """
    Relationship condition.
    """
    oem: SearchByComplexRelationOemsQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    oem_id: SearchByScalarID
    @searchByProperty

    """
    Property condition.
    """
    sku: SearchByScalarString
    @searchByProperty
}

"""
Available conditions for `input PspsQuery` (only one property allowed at a time).
"""
input SearchByConditionPspsQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionPspsQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionPspsQuery!]
    @searchByOperatorAnyOf

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Property condition.
    """
    key: SearchByScalarString
    @searchByProperty

    """
    Property condition.
    """
    name: SearchByScalarString
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionPspsQuery
    @searchByOperatorNot
}

"""
Available conditions for `input QuoteStatusesQuery` (only one property allowed at a time).
"""
input SearchByConditionQuoteStatusesQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionQuoteStatusesQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionQuoteStatusesQuery!]
    @searchByOperatorAnyOf

    """
    Not.
    """
    not: SearchByConditionQuoteStatusesQuery
    @searchByOperatorNot

    """
    Relationship condition.
    """
    quotes: SearchByComplexRelationDocumentsQuery
    @searchByOperatorRelation
}

"""
Available conditions for `input QuoteTypesQuery` (only one property allowed at a time).
"""
input SearchByConditionQuoteTypesQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionQuoteTypesQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionQuoteTypesQuery!]
    @searchByOperatorAnyOf

    """
    Not.
    """
    not: SearchByConditionQuoteTypesQuery
    @searchByOperatorNot

    """
    Relationship condition.
    """
    quotes: SearchByComplexRelationDocumentsQuery
    @searchByOperatorRelation
}

"""
Available conditions for `input ServiceGroupsQuery` (only one property allowed at a time).
"""
input SearchByConditionServiceGroupsQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionServiceGroupsQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionServiceGroupsQuery!]
    @searchByOperatorAnyOf

    """
    Relationship condition.
    """
    documentEntries: SearchByComplexRelationDocumentEntriesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionServiceGroupsQuery
    @searchByOperatorNot

    """
    Relationship condition.
    """
    oem: SearchByComplexRelationOemsQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    oem_id: SearchByScalarID
    @searchByProperty

    """
    Property condition.
    """
    sku: SearchByScalarString
    @searchByProperty
}

"""
Available conditions for `input ServiceLevelsQuery` (only one property allowed at a time).
"""
input SearchByConditionServiceLevelsQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionServiceLevelsQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionServiceLevelsQuery!]
    @searchByOperatorAnyOf

    """
    Relationship condition.
    """
    documentEntries: SearchByComplexRelationDocumentEntriesQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionServiceLevelsQuery
    @searchByOperatorNot

    """
    Relationship condition.
    """
    oem: SearchByComplexRelationOemsQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    oem_id: SearchByScalarID
    @searchByProperty

    """
    Relationship condition.
    """
    serviceGroup: SearchByComplexRelationServiceGroupsQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    service_group_id: SearchByScalarID
    @searchByProperty

    """
    Property condition.
    """
    sku: SearchByScalarString
    @searchByProperty
}

"""
Available conditions for `input StatusesQuery` (only one property allowed at a time).
"""
input SearchByConditionStatusesQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionStatusesQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionStatusesQuery!]
    @searchByOperatorAnyOf

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionStatusesQuery
    @searchByOperatorNot
}

"""
Available conditions for `input TagsQuery` (only one property allowed at a time).
"""
input SearchByConditionTagsQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionTagsQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionTagsQuery!]
    @searchByOperatorAnyOf

    """
    Relationship condition.
    """
    assets: SearchByComplexRelationAssetsQuery
    @searchByOperatorRelation

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Property condition.
    """
    name: SearchByScalarString
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionTagsQuery
    @searchByOperatorNot
}

"""
Available conditions for `input TypesQuery` (only one property allowed at a time).
"""
input SearchByConditionTypesQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionTypesQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionTypesQuery!]
    @searchByOperatorAnyOf

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionTypesQuery
    @searchByOperatorNot
}

"""
Available conditions for `input UsersQuery` (only one property allowed at a time).
"""
input SearchByConditionUsersQuery {
    """
    All of the conditions must be true.
    """
    allOf: [SearchByConditionUsersQuery!]
    @searchByOperatorAllOf

    """
    Any of the conditions must be true.
    """
    anyOf: [SearchByConditionUsersQuery!]
    @searchByOperatorAnyOf

    """
    Property condition.
    """
    email: SearchByScalarEmail
    @searchByProperty

    """
    Property condition.
    """
    enabled: SearchByScalarBoolean
    @searchByProperty

    """
    Property condition.
    """
    family_name: SearchByScalarString
    @searchByProperty

    """
    Property condition.
    """
    given_name: SearchByScalarString
    @searchByProperty

    """
    Property condition.
    """
    id: SearchByScalarID
    @searchByProperty

    """
    Not.
    """
    not: SearchByConditionUsersQuery
    @searchByOperatorNot

    """
    Property condition.
    """
    previous_sign_in: SearchByScalarDateTimeOrNull
    @searchByProperty
}

"""
Available operators for `enum OrganizationType` (only one operator allowed at a time).
"""
input SearchByEnumOrganizationType {
    """
    Equal (`=`).
    """
    equal: OrganizationType
    @searchByOperatorEqual

    """
    Within a set of values.
    """
    in: [OrganizationType!]
    @searchByOperatorIn

    """
    Not Equal (`!=`).
    """
    notEqual: OrganizationType
    @searchByOperatorNotEqual

    """
    Outside a set of values.
    """
    notIn: [OrganizationType!]
    @searchByOperatorNotIn
}

"""
Available operators for `scalar Boolean!` (only one operator allowed at a time).
"""
input SearchByScalarBoolean {
    """
    Equal (`=`).
    """
    equal: Boolean
    @searchByOperatorEqual
}

"""
Available operators for `scalar Boolean` (only one operator allowed at a time).
"""
input SearchByScalarBooleanOrNull {
    """
    Equal (`=`).
    """
    equal: Boolean
    @searchByOperatorEqual

    """
    Is NOT NULL?
    """
    isNotNull: SearchByTypeFlag
    @searchByOperatorIsNotNull

    """
    Is NULL?
    """
    isNull: SearchByTypeFlag
    @searchByOperatorIsNull
}

"""
Available operators for `scalar Date!` (only one operator allowed at a time).
"""
input SearchByScalarDate {
    """
    Within a range.
    """
    between: SearchByTypeRangeDate
    @searchByOperatorBetween

    """
    Equal (`=`).
    """
    equal: Date
    @searchByOperatorEqual

    """
    Greater than (`>`).
    """
    greaterThan: Date
    @searchByOperatorGreaterThan

    """
    Greater than or equal to (`>=`).
    """
    greaterThanOrEqual: Date
    @searchByOperatorGreaterThanOrEqual

    """
    Within a set of values.
    """
    in: [Date!]
    @searchByOperatorIn

    """
    Less than (`<`).
    """
    lessThan: Date
    @searchByOperatorLessThan

    """
    Less than or equal to (`<=`).
    """
    lessThanOrEqual: Date
    @searchByOperatorLessThanOrEqual

    """
    Outside a range.
    """
    notBetween: SearchByTypeRangeDate
    @searchByOperatorNotBetween

    """
    Not Equal (`!=`).
    """
    notEqual: Date
    @searchByOperatorNotEqual

    """
    Outside a set of values.
    """
    notIn: [Date!]
    @searchByOperatorNotIn
}

"""
Available operators for `scalar Date` (only one operator allowed at a time).
"""
input SearchByScalarDateOrNull {
    """
    Within a range.
    """
    between: SearchByTypeRangeDate
    @searchByOperatorBetween

    """
    Equal (`=`).
    """
    equal: Date
    @searchByOperatorEqual

    """
    Greater than (`>`).
    """
    greaterThan: Date
    @searchByOperatorGreaterThan

    """
    Greater than or equal to (`>=`).
    """
    greaterThanOrEqual: Date
    @searchByOperatorGreaterThanOrEqual

    """
    Within a set of values.
    """
    in: [Date!]
    @searchByOperatorIn

    """
    Is NOT NULL?
    """
    isNotNull: SearchByTypeFlag
    @searchByOperatorIsNotNull

    """
    Is NULL?
    """
    isNull: SearchByTypeFlag
    @searchByOperatorIsNull

    """
    Less than (`<`).
    """
    lessThan: Date
    @searchByOperatorLessThan

    """
    Less than or equal to (`<=`).
    """
    lessThanOrEqual: Date
    @searchByOperatorLessThanOrEqual

    """
    Outside a range.
    """
    notBetween: SearchByTypeRangeDate
    @searchByOperatorNotBetween

    """
    Not Equal (`!=`).
    """
    notEqual: Date
    @searchByOperatorNotEqual

    """
    Outside a set of values.
    """
    notIn: [Date!]
    @searchByOperatorNotIn
}

"""
Available operators for `scalar DateTime!` (only one operator allowed at a time).
"""
input SearchByScalarDateTime {
    """
    Within a range.
    """
    between: SearchByTypeRangeDateTime
    @searchByOperatorBetween

    """
    Equal (`=`).
    """
    equal: DateTime
    @searchByOperatorEqual

    """
    Greater than (`>`).
    """
    greaterThan: DateTime
    @searchByOperatorGreaterThan

    """
    Greater than or equal to (`>=`).
    """
    greaterThanOrEqual: DateTime
    @searchByOperatorGreaterThanOrEqual

    """
    Within a set of values.
    """
    in: [DateTime!]
    @searchByOperatorIn

    """
    Less than (`<`).
    """
    lessThan: DateTime
    @searchByOperatorLessThan

    """
    Less than or equal to (`<=`).
    """
    lessThanOrEqual: DateTime
    @searchByOperatorLessThanOrEqual

    """
    Outside a range.
    """
    notBetween: SearchByTypeRangeDateTime
    @searchByOperatorNotBetween

    """
    Not Equal (`!=`).
    """
    notEqual: DateTime
    @searchByOperatorNotEqual

    """
    Outside a set of values.
    """
    notIn: [DateTime!]
    @searchByOperatorNotIn
}

"""
Available operators for `scalar DateTime` (only one operator allowed at a time).
"""
input SearchByScalarDateTimeOrNull {
    """
    Within a range.
    """
    between: SearchByTypeRangeDateTime
    @searchByOperatorBetween

    """
    Equal (`=`).
    """
    equal: DateTime
    @searchByOperatorEqual

    """
    Greater than (`>`).
    """
    greaterThan: DateTime
    @searchByOperatorGreaterThan

    """
    Greater than or equal to (`>=`).
    """
    greaterThanOrEqual: DateTime
    @searchByOperatorGreaterThanOrEqual

    """
    Within a set of values.
    """
    in: [DateTime!]
    @searchByOperatorIn

    """
    Is NOT NULL?
    """
    isNotNull: SearchByTypeFlag
    @searchByOperatorIsNotNull

    """
    Is NULL?
    """
    isNull: SearchByTypeFlag
    @searchByOperatorIsNull

    """
    Less than (`<`).
    """
    lessThan: DateTime
    @searchByOperatorLessThan

    """
    Less than or equal to (`<=`).
    """
    lessThanOrEqual: DateTime
    @searchByOperatorLessThanOrEqual

    """
    Outside a range.
    """
    notBetween: SearchByTypeRangeDateTime
    @searchByOperatorNotBetween

    """
    Not Equal (`!=`).
    """
    notEqual: DateTime
    @searchByOperatorNotEqual

    """
    Outside a set of values.
    """
    notIn: [DateTime!]
    @searchByOperatorNotIn
}

"""
Available operators for `scalar Email!` (only one operator allowed at a time).
"""
input SearchByScalarEmail {
    """
    Contains.
    """
    contains: Email
    @searchByOperatorContains

    """
    Ends with a string.
    """
    endsWith: Email
    @searchByOperatorEndsWith

    """
    Equal (`=`).
    """
    equal: Email
    @searchByOperatorEqual

    """
    Within a set of values.
    """
    in: [Email!]
    @searchByOperatorIn

    """
    Not Equal (`!=`).
    """
    notEqual: Email
    @searchByOperatorNotEqual

    """
    Outside a set of values.
    """
    notIn: [Email!]
    @searchByOperatorNotIn

    """
    Starts with a string.
    """
    startsWith: Email
    @searchByOperatorStartsWith
}

"""
Available operators for `scalar Email` (only one operator allowed at a time).
"""
input SearchByScalarEmailOrNull {
    """
    Contains.
    """
    contains: Email
    @searchByOperatorContains

    """
    Ends with a string.
    """
    endsWith: Email
    @searchByOperatorEndsWith

    """
    Equal (`=`).
    """
    equal: Email
    @searchByOperatorEqual

    """
    Within a set of values.
    """
    in: [Email!]
    @searchByOperatorIn

    """
    Is NOT NULL?
    """
    isNotNull: SearchByTypeFlag
    @searchByOperatorIsNotNull

    """
    Is NULL?
    """
    isNull: SearchByTypeFlag
    @searchByOperatorIsNull

    """
    Not Equal (`!=`).
    """
    notEqual: Email
    @searchByOperatorNotEqual

    """
    Outside a set of values.
    """
    notIn: [Email!]
    @searchByOperatorNotIn

    """
    Starts with a string.
    """
    startsWith: Email
    @searchByOperatorStartsWith
}

"""
Available operators for `scalar Float` (only one operator allowed at a time).
"""
input SearchByScalarFloatOrNull {
    """
    Within a range.
    """
    between: SearchByTypeRangeFloat
    @searchByOperatorBetween

    """
    Equal (`=`).
    """
    equal: Float
    @searchByOperatorEqual

    """
    Greater than (`>`).
    """
    greaterThan: Float
    @searchByOperatorGreaterThan

    """
    Greater than or equal to (`>=`).
    """
    greaterThanOrEqual: Float
    @searchByOperatorGreaterThanOrEqual

    """
    Within a set of values.
    """
    in: [Float!]
    @searchByOperatorIn

    """
    Is NOT NULL?
    """
    isNotNull: SearchByTypeFlag
    @searchByOperatorIsNotNull

    """
    Is NULL?
    """
    isNull: SearchByTypeFlag
    @searchByOperatorIsNull

    """
    Less than (`<`).
    """
    lessThan: Float
    @searchByOperatorLessThan

    """
    Less than or equal to (`<=`).
    """
    lessThanOrEqual: Float
    @searchByOperatorLessThanOrEqual

    """
    Outside a range.
    """
    notBetween: SearchByTypeRangeFloat
    @searchByOperatorNotBetween

    """
    Not Equal (`!=`).
    """
    notEqual: Float
    @searchByOperatorNotEqual

    """
    Outside a set of values.
    """
    notIn: [Float!]
    @searchByOperatorNotIn
}

"""
Available operators for `scalar HtmlString` (only one operator allowed at a time).
"""
input SearchByScalarHtmlStringOrNull {
    """
    Contains.
    """
    contains: HtmlString
    @searchByOperatorContains

    """
    Ends with a string.
    """
    endsWith: HtmlString
    @searchByOperatorEndsWith

    """
    Equal (`=`).
    """
    equal: HtmlString
    @searchByOperatorEqual

    """
    Within a set of values.
    """
    in: [HtmlString!]
    @searchByOperatorIn

    """
    Is NOT NULL?
    """
    isNotNull: SearchByTypeFlag
    @searchByOperatorIsNotNull

    """
    Is NULL?
    """
    isNull: SearchByTypeFlag
    @searchByOperatorIsNull

    """
    Not Equal (`!=`).
    """
    notEqual: HtmlString
    @searchByOperatorNotEqual

    """
    Outside a set of values.
    """
    notIn: [HtmlString!]
    @searchByOperatorNotIn

    """
    Starts with a string.
    """
    startsWith: HtmlString
    @searchByOperatorStartsWith
}

"""
Available operators for `scalar ID!` (only one operator allowed at a time).
"""
input SearchByScalarID {
    """
    Equal (`=`).
    """
    equal: ID
    @searchByOperatorEqual

    """
    Within a set of values.
    """
    in: [ID!]
    @searchByOperatorIn

    """
    Not Equal (`!=`).
    """
    notEqual: ID
    @searchByOperatorNotEqual

    """
    Outside a set of values.
    """
    notIn: [ID!]
    @searchByOperatorNotIn
}

"""
Available operators for `scalar ID` (only one operator allowed at a time).
"""
input SearchByScalarIDOrNull {
    """
    Equal (`=`).
    """
    equal: ID
    @searchByOperatorEqual

    """
    Within a set of values.
    """
    in: [ID!]
    @searchByOperatorIn

    """
    Is NOT NULL?
    """
    isNotNull: SearchByTypeFlag
    @searchByOperatorIsNotNull

    """
    Is NULL?
    """
    isNull: SearchByTypeFlag
    @searchByOperatorIsNull

    """
    Not Equal (`!=`).
    """
    notEqual: ID
    @searchByOperatorNotEqual

    """
    Outside a set of values.
    """
    notIn: [ID!]
    @searchByOperatorNotIn
}

"""
Available operators for `scalar Int!` (only one operator allowed at a time).
"""
input SearchByScalarInt {
    """
    Within a range.
    """
    between: SearchByTypeRangeInt
    @searchByOperatorBetween

    """
    Bitwise AND (`&`).
    """
    bitwiseAnd: Int
    @searchByOperatorBitwiseAnd

    """
    Bitwise Left shift (`<<`).
    """
    bitwiseLeftShift: Int
    @searchByOperatorBitwiseLeftShift

    """
    Bitwise OR (`|`).
    """
    bitwiseOr: Int
    @searchByOperatorBitwiseOr

    """
    Bitwise Right shift (`>>`).
    """
    bitwiseRightShift: Int
    @searchByOperatorBitwiseRightShift

    """
    Bitwise XOR (`^`).
    """
    bitwiseXor: Int
    @searchByOperatorBitwiseXor

    """
    Equal (`=`).
    """
    equal: Int
    @searchByOperatorEqual

    """
    Greater than (`>`).
    """
    greaterThan: Int
    @searchByOperatorGreaterThan

    """
    Greater than or equal to (`>=`).
    """
    greaterThanOrEqual: Int
    @searchByOperatorGreaterThanOrEqual

    """
    Within a set of values.
    """
    in: [Int!]
    @searchByOperatorIn

    """
    Less than (`<`).
    """
    lessThan: Int
    @searchByOperatorLessThan

    """
    Less than or equal to (`<=`).
    """
    lessThanOrEqual: Int
    @searchByOperatorLessThanOrEqual

    """
    Outside a range.
    """
    notBetween: SearchByTypeRangeInt
    @searchByOperatorNotBetween

    """
    Not Equal (`!=`).
    """
    notEqual: Int
    @searchByOperatorNotEqual

    """
    Outside a set of values.
    """
    notIn: [Int!]
    @searchByOperatorNotIn
}

"""
Available operators for `scalar Int` (only one operator allowed at a time).
"""
input SearchByScalarIntOrNull {
    """
    Within a range.
    """
    between: SearchByTypeRangeInt
    @searchByOperatorBetween

    """
    Bitwise AND (`&`).
    """
    bitwiseAnd: Int
    @searchByOperatorBitwiseAnd

    """
    Bitwise Left shift (`<<`).
    """
    bitwiseLeftShift: Int
    @searchByOperatorBitwiseLeftShift

    """
    Bitwise OR (`|`).
    """
    bitwiseOr: Int
    @searchByOperatorBitwiseOr

    """
    Bitwise Right shift (`>>`).
    """
    bitwiseRightShift: Int
    @searchByOperatorBitwiseRightShift

    """
    Bitwise XOR (`^`).
    """
    bitwiseXor: Int
    @searchByOperatorBitwiseXor

    """
    Equal (`=`).
    """
    equal: Int
    @searchByOperatorEqual

    """
    Greater than (`>`).
    """
    greaterThan: Int
    @searchByOperatorGreaterThan

    """
    Greater than or equal to (`>=`).
    """
    greaterThanOrEqual: Int
    @searchByOperatorGreaterThanOrEqual

    """
    Within a set of values.
    """
    in: [Int!]
    @searchByOperatorIn

    """
    Is NOT NULL?
    """
    isNotNull: SearchByTypeFlag
    @searchByOperatorIsNotNull

    """
    Is NULL?
    """
    isNull: SearchByTypeFlag
    @searchByOperatorIsNull

    """
    Less than (`<`).
    """
    lessThan: Int
    @searchByOperatorLessThan

    """
    Less than or equal to (`<=`).
    """
    lessThanOrEqual: Int
    @searchByOperatorLessThanOrEqual

    """
    Outside a range.
    """
    notBetween: SearchByTypeRangeInt
    @searchByOperatorNotBetween

    """
    Not Equal (`!=`).
    """
    notEqual: Int
    @searchByOperatorNotEqual

    """
    Outside a set of values.
    """
    notIn: [Int!]
    @searchByOperatorNotIn
}

"""
Available operators for `scalar PhoneNumber` (only one operator allowed at a time).
"""
input SearchByScalarPhoneNumberOrNull {
    """
    Contains.
    """
    contains: PhoneNumber
    @searchByOperatorContains

    """
    Ends with a string.
    """
    endsWith: PhoneNumber
    @searchByOperatorEndsWith

    """
    Equal (`=`).
    """
    equal: PhoneNumber
    @searchByOperatorEqual

    """
    Within a set of values.
    """
    in: [PhoneNumber!]
    @searchByOperatorIn

    """
    Is NOT NULL?
    """
    isNotNull: SearchByTypeFlag
    @searchByOperatorIsNotNull

    """
    Is NULL?
    """
    isNull: SearchByTypeFlag
    @searchByOperatorIsNull

    """
    Not Equal (`!=`).
    """
    notEqual: PhoneNumber
    @searchByOperatorNotEqual

    """
    Outside a set of values.
    """
    notIn: [PhoneNumber!]
    @searchByOperatorNotIn

    """
    Starts with a string.
    """
    startsWith: PhoneNumber
    @searchByOperatorStartsWith
}

"""
Available operators for `scalar String!` (only one operator allowed at a time).
"""
input SearchByScalarString {
    """
    Contains.
    """
    contains: String
    @searchByOperatorContains

    """
    Ends with a string.
    """
    endsWith: String
    @searchByOperatorEndsWith

    """
    Equal (`=`).
    """
    equal: String
    @searchByOperatorEqual

    """
    Within a set of values.
    """
    in: [String!]
    @searchByOperatorIn

    """
    Not Equal (`!=`).
    """
    notEqual: String
    @searchByOperatorNotEqual

    """
    Outside a set of values.
    """
    notIn: [String!]
    @searchByOperatorNotIn

    """
    Starts with a string.
    """
    startsWith: String
    @searchByOperatorStartsWith
}

"""
Available operators for `scalar String` (only one operator allowed at a time).
"""
input SearchByScalarStringOrNull {
    """
    Contains.
    """
    contains: String
    @searchByOperatorContains

    """
    Ends with a string.
    """
    endsWith: String
    @searchByOperatorEndsWith

    """
    Equal (`=`).
    """
    equal: String
    @searchByOperatorEqual

    """
    Within a set of values.
    """
    in: [String!]
    @searchByOperatorIn

    """
    Is NOT NULL?
    """
    isNotNull: SearchByTypeFlag
    @searchByOperatorIsNotNull

    """
    Is NULL?
    """
    isNull: SearchByTypeFlag
    @searchByOperatorIsNull

    """
    Not Equal (`!=`).
    """
    notEqual: String
    @searchByOperatorNotEqual

    """
    Outside a set of values.
    """
    notIn: [String!]
    @searchByOperatorNotIn

    """
    Starts with a string.
    """
    startsWith: String
    @searchByOperatorStartsWith
}

"""
Available operators for `scalar Url` (only one operator allowed at a time).
"""
input SearchByScalarUrlOrNull {
    """
    Contains.
    """
    contains: Url
    @searchByOperatorContains

    """
    Ends with a string.
    """
    endsWith: Url
    @searchByOperatorEndsWith

    """
    Equal (`=`).
    """
    equal: Url
    @searchByOperatorEqual

    """
    Within a set of values.
    """
    in: [Url!]
    @searchByOperatorIn

    """
    Is NOT NULL?
    """
    isNotNull: SearchByTypeFlag
    @searchByOperatorIsNotNull

    """
    Is NULL?
    """
    isNull: SearchByTypeFlag
    @searchByOperatorIsNull

    """
    Not Equal (`!=`).
    """
    notEqual: Url
    @searchByOperatorNotEqual

    """
    Outside a set of values.
    """
    notIn: [Url!]
    @searchByOperatorNotIn

    """
    Starts with a string.
    """
    startsWith: Url
    @searchByOperatorStartsWith
}

input SearchByTypeRangeDate {
    max: Date!
    min: Date!
}

input SearchByTypeRangeDateTime {
    max: DateTime!
    min: DateTime!
}

input SearchByTypeRangeFloat {
    max: Float!
    min: Float!
}

input SearchByTypeRangeInt {
    max: Int!
    min: Int!
}

input SendResetPasswordLinkInput {
    email: Email!
}

input SetApplicationLocaleInput {
    locale: String!
    @rules(
        apply: ["App\\Rules\\Locale"]
    )
}

"""
Sort clause for input ApplicationLogsSort (only one property allowed at a time).
"""
input SortByClauseApplicationLogsSort {
    """
    Property clause.
    """
    created_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    duration: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    finished_at: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input AssetsSearchCustomerSort (only one property allowed at a time).
"""
input SortByClauseAssetsSearchCustomerSort {
    """
    Property clause.
    """
    name: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input AssetsSearchProductSort (only one property allowed at a time).
"""
input SortByClauseAssetsSearchProductSort {
    """
    Property clause.
    """
    name: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    sku: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input AssetsSearchSort (only one property allowed at a time).
"""
input SortByClauseAssetsSearchSort {
    """
    Property clause.
    """
    customer: SortByClauseAssetsSearchCustomerSort
    @sortByProperty

    """
    Property clause.
    """
    nickname: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    product: SortByClauseAssetsSearchProductSort
    @sortByProperty

    """
    Property clause.
    """
    serial_number: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input AssetsSort (only one property allowed at a time).
"""
input SortByClauseAssetsSort {
    """
    Property clause.
    """
    contacts_active_quantity: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    created_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    customer: SortByClauseCompaniesSort
    @sortByProperty

    """
    Property clause.
    """
    deleted_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    location: SortByClauseLocationsSort
    @sortByProperty

    """
    Property clause.
    """
    nickname: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    oem: SortByClauseOemsSort
    @sortByProperty

    """
    Property clause.
    """
    product: SortByClauseProductsSort
    @sortByProperty

    """
    Property clause.
    """
    reseller: SortByClauseCompaniesSort
    @sortByProperty

    """
    Property clause.
    """
    serial_number: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    status: SortByClauseStatusesSort
    @sortByProperty

    """
    Property clause.
    """
    type: SortByClauseTypesSort
    @sortByProperty

    """
    Property clause.
    """
    updated_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    warrantyServiceGroup: SortByClauseServiceGroupsSort
    @sortByProperty

    """
    Property clause.
    """
    warrantyServiceLevel: SortByClauseServiceLevelsSort
    @sortByProperty

    """
    Property clause.
    """
    warranty_end: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    warranty_service_group_id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    warranty_service_level_id: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input AuditsSort (only one property allowed at a time).
"""
input SortByClauseAuditsSort {
    """
    Property clause.
    """
    action: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    created_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    object_id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    object_type: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    organization_id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    updated_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    user_id: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input ChangeRequestsSort (only one property allowed at a time).
"""
input SortByClauseChangeRequestsSort {
    """
    Property clause.
    """
    created_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    deleted_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    from: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    updated_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    user: SortByClauseUsersSort
    @sortByProperty

    """
    Property clause.
    """
    user_id: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input CitiesSort (only one property allowed at a time).
"""
input SortByClauseCitiesSort {
    """
    Property clause.
    """
    country: SortByClauseCountriesSort
    @sortByProperty

    """
    Property clause.
    """
    id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    name: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input CompaniesSort (only one property allowed at a time).
"""
input SortByClauseCompaniesSort {
    """
    Property clause.
    """
    assets_count: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    contacts_count: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    contracts_count: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    created_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    deleted_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    headquarter: SortByClauseCompanyLocationsSort
    @sortByProperty

    """
    Property clause.
    """
    locations_count: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    name: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    quotes_count: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    updated_at: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input CompanyLocationsSort (only one property allowed at a time).
"""
input SortByClauseCompanyLocationsSort {
    """
    Property clause.
    """
    location: SortByClauseLocationsSort
    @sortByProperty
}

"""
Sort clause for input ContactsSort (only one property allowed at a time).
"""
input SortByClauseContactsSort {
    """
    Property clause.
    """
    created_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    deleted_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    email: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    name: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    phone_number: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    phone_valid: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    updated_at: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input CountriesSort (only one property allowed at a time).
"""
input SortByClauseCountriesSort {
    """
    Property clause.
    """
    code: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    name: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input CurrenciesSort (only one property allowed at a time).
"""
input SortByClauseCurrenciesSort {
    """
    Property clause.
    """
    code: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input CustomersSearchHeadquarterCitySort (only one property allowed at a time).
"""
input SortByClauseCustomersSearchHeadquarterCitySort {
    """
    Property clause.
    """
    name: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input CustomersSearchHeadquarterSort (only one property allowed at a time).
"""
input SortByClauseCustomersSearchHeadquarterSort {
    """
    Property clause.
    """
    city: SortByClauseCustomersSearchHeadquarterCitySort
    @sortByProperty
}

"""
Sort clause for input CustomersSearchSort (only one property allowed at a time).
"""
input SortByClauseCustomersSearchSort {
    """
    Property clause.
    """
    headquarter: SortByClauseCustomersSearchHeadquarterSort
    @sortByProperty

    """
    Property clause.
    """
    name: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input DistributorsSort (only one property allowed at a time).
"""
input SortByClauseDistributorsSort {
    """
    Property clause.
    """
    created_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    deleted_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    name: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    updated_at: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input DocumentEntriesSort (only one property allowed at a time).
"""
input SortByClauseDocumentEntriesSort {
    """
    Property clause.
    """
    asset: SortByClauseAssetsSort
    @sortByProperty

    """
    Property clause.
    """
    assetType: SortByClauseTypesSort
    @sortByProperty

    """
    Property clause.
    """
    asset_id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    asset_type_id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    created_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    currency: SortByClauseCurrenciesSort
    @sortByProperty

    """
    Property clause.
    """
    currency_id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    deleted_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    end: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    environment_id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    equipment_number: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    language: SortByClauseLanguagesSort
    @sortByProperty

    """
    Property clause.
    """
    language_id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    list_price: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    monthly_list_price: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    monthly_retail_price: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    oem_said: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    oem_sar_number: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    product: SortByClauseProductsSort
    @sortByProperty

    """
    Property clause.
    """
    productGroup: SortByClauseProductGroupsSort
    @sortByProperty

    """
    Property clause.
    """
    productLine: SortByClauseProductLinesSort
    @sortByProperty

    """
    Property clause.
    """
    product_group_id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    product_id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    product_line_id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    psp: SortByClausePspsSort
    @sortByProperty

    """
    Property clause.
    """
    psp_id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    renewal: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    serial_number: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    serviceGroup: SortByClauseServiceGroupsSort
    @sortByProperty

    """
    Property clause.
    """
    serviceLevel: SortByClauseServiceLevelsSort
    @sortByProperty

    """
    Property clause.
    """
    service_group_id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    service_level_id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    start: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    updated_at: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input DocumentsSearchCustomerSort (only one property allowed at a time).
"""
input SortByClauseDocumentsSearchCustomerSort {
    """
    Property clause.
    """
    name: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input DocumentsSearchEntriesProductSort (only one property allowed at a time).
"""
input SortByClauseDocumentsSearchEntriesProductSort {
    """
    Property clause.
    """
    name: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    sku: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input DocumentsSearchEntriesSort (only one property allowed at a time).
"""
input SortByClauseDocumentsSearchEntriesSort {
    """
    Property clause.
    """
    product: SortByClauseDocumentsSearchEntriesProductSort
    @sortByProperty

    """
    Property clause.
    """
    serial_number: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input DocumentsSearchSort (only one property allowed at a time).
"""
input SortByClauseDocumentsSearchSort {
    """
    Property clause.
    """
    customer: SortByClauseDocumentsSearchCustomerSort
    @sortByProperty

    """
    Property clause.
    """
    end: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    entries: SortByClauseDocumentsSearchEntriesSort
    @sortByProperty

    """
    Property clause.
    """
    number: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    start: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input DocumentsSort (only one property allowed at a time).
"""
input SortByClauseDocumentsSort {
    """
    Property clause.
    """
    created_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    currency: SortByClauseCurrenciesSort
    @sortByProperty

    """
    Property clause.
    """
    customer: SortByClauseCompaniesSort
    @sortByProperty

    """
    Property clause.
    """
    deleted_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    distributor: SortByClauseDistributorsSort
    @sortByProperty

    """
    Property clause.
    """
    end: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    language: SortByClauseLanguagesSort
    @sortByProperty

    """
    Property clause.
    """
    number: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    oem: SortByClauseOemsSort
    @sortByProperty

    """
    Property clause.
    """
    oemGroup: SortByClauseOemGroupsSort
    @sortByProperty

    """
    Property clause.
    """
    oem_amp_id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    oem_said: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    oem_sar_number: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    price: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    reseller: SortByClauseCompaniesSort
    @sortByProperty

    """
    Property clause.
    """
    start: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    updated_at: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input LanguagesSort (only one property allowed at a time).
"""
input SortByClauseLanguagesSort {
    """
    Property clause.
    """
    code: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input LocationsSort (only one property allowed at a time).
"""
input SortByClauseLocationsSort {
    """
    Property clause.
    """
    city: SortByClauseCitiesSort
    @sortByProperty

    """
    Property clause.
    """
    country: SortByClauseCountriesSort
    @sortByProperty

    """
    Property clause.
    """
    created_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    deleted_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    line_one: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    line_two: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    postcode: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    state: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    updated_at: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input MeSearchSort (only one property allowed at a time).
"""
input SortByClauseMeSearchSort {
    """
    Property clause.
    """
    created_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    deleted_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    key: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    name: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    updated_at: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input NotesSort (only one property allowed at a time).
"""
input SortByClauseNotesSort {
    """
    Property clause.
    """
    created_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    deleted_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    pinned: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    updated_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    user: SortByClauseUsersSort
    @sortByProperty

    """
    Property clause.
    """
    user_id: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input OemGroupsSort (only one property allowed at a time).
"""
input SortByClauseOemGroupsSort {
    """
    Property clause.
    """
    created_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    deleted_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    key: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    name: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    updated_at: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input OemsSort (only one property allowed at a time).
"""
input SortByClauseOemsSort {
    """
    Property clause.
    """
    id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    key: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    name: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input OrganizationsSort (only one property allowed at a time).
"""
input SortByClauseOrganizationsSort {
    """
    Property clause.
    """
    created_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    deleted_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    email: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    name: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    updated_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    website_url: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input ProductGroupsSort (only one property allowed at a time).
"""
input SortByClauseProductGroupsSort {
    """
    Property clause.
    """
    id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    key: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    name: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input ProductLinesSort (only one property allowed at a time).
"""
input SortByClauseProductLinesSort {
    """
    Property clause.
    """
    id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    key: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    name: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input ProductsSort (only one property allowed at a time).
"""
input SortByClauseProductsSort {
    """
    Property clause.
    """
    eol: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    eos: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    name: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    oem: SortByClauseOemsSort
    @sortByProperty

    """
    Property clause.
    """
    sku: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input PspsSort (only one property allowed at a time).
"""
input SortByClausePspsSort {
    """
    Property clause.
    """
    id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    key: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    name: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input ServiceGroupsSort (only one property allowed at a time).
"""
input SortByClauseServiceGroupsSort {
    """
    Property clause.
    """
    oem: SortByClauseOemsSort
    @sortByProperty

    """
    Property clause.
    """
    sku: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input ServiceLevelsSort (only one property allowed at a time).
"""
input SortByClauseServiceLevelsSort {
    """
    Property clause.
    """
    oem: SortByClauseOemsSort
    @sortByProperty

    """
    Property clause.
    """
    serviceGroup: SortByClauseServiceGroupsSort
    @sortByProperty

    """
    Property clause.
    """
    sku: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input StatusesSort (only one property allowed at a time).
"""
input SortByClauseStatusesSort {
    """
    Property clause.
    """
    name: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for type Tag (only one property allowed at a time).
"""
input SortByClauseTag {
    """
    Property clause.
    """
    id: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    name: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input TypesSort (only one property allowed at a time).
"""
input SortByClauseTypesSort {
    """
    Property clause.
    """
    name: SortByTypeDirection
    @sortByOperatorProperty
}

"""
Sort clause for input UsersSort (only one property allowed at a time).
"""
input SortByClauseUsersSort {
    """
    Property clause.
    """
    created_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    deleted_at: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    email: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    enabled: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    family_name: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    given_name: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    previous_sign_in: SortByTypeDirection
    @sortByOperatorProperty

    """
    Property clause.
    """
    updated_at: SortByTypeDirection
    @sortByOperatorProperty
}

input StopApplicationServiceInput {
    """
    Name of the service.
    """
    name: String!
}

input TranslatedStringInput {
    locale: String!
    text: String!
}

input UpdateApplicationSettingsInput
@validator(
    class: "App\\GraphQL\\Validators\\UpdateApplicationSettingsInputValidator"
)
{
    name: String!
    value: String!
}

input UpdateClientSettingsInput {
    name: String!
    value: String!
}

input UpdateContractNoteFile {
    content: Upload
    id: ID
}

input UpdateContractNoteInput
@validator(
    class: "App\\GraphQL\\Validators\\UpdateContractNoteInputValidator"
)
{
    files: [UpdateContractNoteFile!]
    id: ID!
    note: HtmlString
    pinned: Boolean
}

input UpdateMeEmailInput
@validator(
    class: "App\\GraphQL\\Validators\\UpdateMeEmailInputValidator"
)
{
    email: Email!
}

input UpdateMePasswordInput {
    current_password: String
    password: String!
}

input UpdateQuoteNoteFile {
    content: Upload
    id: ID
}

input UpdateQuoteNoteInput
@validator(
    class: "App\\GraphQL\\Validators\\UpdateContractNoteInputValidator"
)
{
    files: [UpdateQuoteNoteFile!]
    id: ID!
    note: HtmlString
    pinned: Boolean
}

input UserOrganizationUpdateInput {
    enabled: Boolean
    @isNotMe
    @isRequired

    role_id: ID
    @isNotMe
    @isRequired
    @isOrganizationRoleId

    team_id: ID
    @isNullable
    @isTeamId
}

input UserUpdateInput {
    academic_title: String
    @isNullable
    @isRequired
    @isMax(
        value: 255
    )

    contact_email: Email
    @isNullable
    @isMax(
        value: 255
    )
    @isEmail

    enabled: Boolean
    @isNotMe
    @isRequired

    family_name: String
    @isRequired
    @isMax(
        value: 255
    )

    given_name: String
    @isRequired
    @isMax(
        value: 255
    )

    homepage: String
    @isNullable
    @isRequired
    @isMax(
        value: 255
    )

    job_title: String
    @isNullable
    @isRequired
    @isMax(
        value: 255
    )

    locale: String
    @isNullable
    @isLocale

    mobile_phone: PhoneNumber
    @isNullable
    @isPhoneNumber

    office_phone: PhoneNumber
    @isNullable
    @isPhoneNumber

    photo: Upload
    @isNullable
    @isImage

    timezone: String
    @isNullable
    @isTimezone

    title: String
    @isNullable
    @isRequired
    @isMax(
        value: 7
    )
}

interface Company {
    changed_at: DateTime
    created_at: DateTime!
    deleted_at: DateTime
    id: ID!

    kpi: Kpi
    @orgRelation

    name: String!

    statuses: [Status!]!
    @relation

    synced_at: DateTime!
    updated_at: DateTime!
}

interface Payload {
    result: Boolean!
}

scalar BuilderValue

"""
The RGB Color (eg `#FF0000`).
"""
scalar Color
@scalar(
    class: "GraphQL\\Type\\Definition\\StringType"
)

"""
ISO 8601 Date string with format Y-m-d (`2011-05-23`).
"""
scalar Date
@scalar(
    class: "App\\GraphQL\\Scalars\\Date"
)

"""
ISO 8601 Date Time string with format `Y-m-dTH:i:sP` (`2018-05-23T13:43:32+00:00`).
"""
scalar DateTime
@scalar(
    class: "App\\GraphQL\\Scalars\\DateTime"
)

"""
The Email.
"""
scalar Email
@scalar(
    class: "GraphQL\\Type\\Definition\\StringType"
)

scalar EqValue

"""
Geohash (https://en.wikipedia.org/wiki/Geohash)
"""
scalar Geohash
@scalar(
    class: "App\\GraphQL\\Scalars\\Geohash"
)

"""
HTML (https://en.wikipedia.org/wiki/HTML).
"""
scalar HtmlString
@scalar(
    class: "App\\GraphQL\\Scalars\\HtmlString"
)

"""
Phone number in E.164 format (https://en.wikipedia.org/wiki/E.164).
"""
scalar PhoneNumber
@scalar(
    class: "GraphQL\\Type\\Definition\\StringType"
)

"""
The `SearchString` scalar type represents textual data, represented as UTF-8
character sequences. It is designed specially to search and supports
the simple syntax:

- `*`: return all objects;
- `abc`: return objects that contains `abc`;
- `abc cde`: return objects that contains `abc` and `cde` (in this order);
- `"abc cde"`: return objects that contains exact phrase `abc cde`;
"""
scalar SearchString
@scalar(
    class: "GraphQL\\Type\\Definition\\StringType"
)

"""
Can be used as an argument to upload files using https://github.com/jaydenseric/graphql-multipart-request-spec
"""
scalar Upload
@scalar(
    class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\Upload"
)

"""
The URL.
"""
scalar Url
@scalar(
    class: "GraphQL\\Type\\Definition\\StringType"
)

type AggregatedGroupByTypeGroup {
    count: Int!
    key: String
}

"""
Aggregated data for `type AggregatedGroupByTypeGroup`.
"""
type AggregatedGroupByTypeGroupsAggregated {
    count: Int!
    @aggregatedCount
    @cached(
        mode: Threshold
    )
}

type Application {
    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authRoot> Authenticated user must be a root.
    """
    jobs: [ApplicationJob!]!
    @authOrgRoot
    @authRoot
    @field(
        resolver: "App\\GraphQL\\Queries\\Application\\Jobs"
    )

    locale: String!
    @field(
        resolver: "App\\GraphQL\\Queries\\Application\\Locale"
    )

    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authRoot> Authenticated user must be a root.
    """
    logs(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseApplicationLogsSort!]
        @sortBy

        where: SearchByConditionApplicationLogsQuery
        @searchBy
    ): [ApplicationLog!]!
    @authOrgRoot
    @authRoot
    @paginated(
        builder: "App\\GraphQL\\Queries\\Application\\Logs"
        model: "App\\Services\\Logger\\Models\\Log"
    )

    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authRoot> Authenticated user must be a root.
    """
    logsAggregated(
        where: SearchByConditionApplicationLogsQuery
        @searchBy
    ): ApplicationLogsAggregated
    @authOrgRoot
    @authRoot
    @aggregated(
        builder: "App\\GraphQL\\Queries\\Application\\Logs"
    )

    maintenance: ApplicationMaintenance
    @field(
        resolver: "App\\GraphQL\\Queries\\Application\\Maintenance"
    )

    name: String!

    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authRoot> Authenticated user must be a root.
    """
    services: [ApplicationService!]!
    @authOrgRoot
    @authRoot
    @field(
        resolver: "App\\GraphQL\\Queries\\Application\\Services"
    )

    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authRoot> Authenticated user must be a root.
    """
    settingGroups: [ApplicationSettingGroup!]!
    @authOrgRoot
    @authRoot
    @field(
        resolver: "App\\GraphQL\\Queries\\Application\\SettingGroups"
    )

    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authRoot> Authenticated user must be a root.
    """
    settings: [ApplicationSetting!]!
    @authOrgRoot
    @authRoot
    @field(
        resolver: "App\\GraphQL\\Queries\\Application\\Settings"
    )

    version: String!
}

type ApplicationJob {
    description: String
    name: String!

    """
    Queue name
    """
    queue: String!

    """
    Settings related to this job.
    """
    settings: [String!]!
}

type ApplicationJobProgress {
    created: Int
    current: Boolean
    deleted: Int
    failed: Int
    name: String
    operations: [ApplicationJobProgress!]
    processed: Int
    success: Int
    total: Int
    updated: Int
}

type ApplicationJobState {
    id: ID!
    pending_at: DateTime
    running: Boolean!
    running_at: DateTime
    stopped: Boolean!
}

type ApplicationLog {
    action: String!
    category: String!

    """
    JSON
    """
    context: String
    @field(
        resolver: "App\\GraphQL\\Resolvers\\JsonResolver"
    )

    created_at: DateTime!

    """
    Seconds
    """
    duration: Float

    finished_at: DateTime
    id: ID!
    object_id: ID
    object_type: String

    """
    JSON
    """
    statistics: String
    @field(
        resolver: "App\\GraphQL\\Resolvers\\JsonResolver"
    )

    """
    Possible values:
    * active
    * success
    * failed
    * unknown
    * killed
    * stopped
    """
    status: String
}

"""
Aggregated data for `type ApplicationLog`.
"""
type ApplicationLogsAggregated {
    count: Int!
    @aggregatedCount
    @cached(
        mode: Threshold
    )

    groups(
        groupBy: AggregatedGroupByClauseApplicationLogsQuery!
        @aggregatedGroupBy(
            order: "ApplicationLogsSort"
            where: "ApplicationLogsQuery"
        )

        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset
    ): [AggregatedGroupByTypeGroup!]!
    @cached(
        mode: Threshold
    )
    @paginated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )

    groupsAggregated(
        groupBy: AggregatedGroupByClauseApplicationLogsQuery!
        @aggregatedGroupBy(
            order: "ApplicationLogsSort"
            where: "ApplicationLogsQuery"
        )
    ): AggregatedGroupByTypeGroupsAggregated
    @aggregated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )
}

type ApplicationMaintenance {
    enabled: Boolean!
    end: DateTime
    message: String
    start: DateTime
}

type ApplicationMaintenanceMutation {
    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authRoot> Authenticated user must be a root.
    """
    schedule(
        input: ApplicationMaintenanceScheduleInput!
    ): ApplicationMaintenanceSchedulePayload
    @authOrgRoot
    @authRoot
    @field(
        resolver: "App\\GraphQL\\Mutations\\Application\\Maintenance\\Schedule"
    )

    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authRoot> Authenticated user must be a root.
    """
    stop: ApplicationMaintenanceStopPayload
    @authOrgRoot
    @authRoot
    @field(
        resolver: "App\\GraphQL\\Mutations\\Application\\Maintenance\\Stop"
    )
}

type ApplicationMaintenanceSchedulePayload {
    result: Boolean!
}

type ApplicationMaintenanceStopPayload {
    result: Boolean!
}

type ApplicationMutation {
    maintenance: ApplicationMaintenanceMutation
    @field(
        resolver: "App\\GraphQL\\Resolvers\\EmptyResolver"
    )
}

type ApplicationService {
    """
    Cron expression that determines when service should run if enabled.
    """
    cron: String

    description: String
    enabled: Boolean!
    name: String!
    progress: ApplicationJobProgress

    """
    Indicates that Service have a progress.
    """
    progressable: Boolean!

    """
    Queue name
    """
    queue: String!

    """
    Settings related to this service.
    """
    settings: [String!]!

    state: ApplicationJobState

    """
    Indicates that Service can be stopped.
    """
    stoppable: Boolean!
}

type ApplicationSetting {
    """
    Indicated that the setting is array.
    """
    array: Boolean!

    """
    Default value.
    """
    default: String!

    description: String

    """
    Indicates that this setting related to job.
    """
    job: Boolean!

    name: String!

    """
    Indicates that the setting is read-only due to configs priority and cannot
    be changed.
    """
    readonly: Boolean!

    """
    Indicates that the setting contains sensitive data (eg password), in this case,
    the real value will not be returned.
    """
    secret: Boolean!

    """
    Indicates that this setting related to service.
    """
    service: Boolean!

    """
    Type. Can be standard GraphQL type like Int, Boolean, etc, or a special
    application type.
    """
    type: String!

    """
    Value of the setting. For array it will contain comma-separated values, for
    Boolean: "true" or "false", also can be "null" that means null.
    """
    value: String!

    """
    Allowed values.
    """
    values: [ApplicationSettingValues!]
}

type ApplicationSettingGroup {
    """
    Group name.
    """
    name: String!

    """
    Settings related to this group.
    """
    settings: [String!]!
}

type Asset {
    changeRequest: ChangeRequest
    @relation

    changeRequests(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseChangeRequestsSort!]
        @sortBy

        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionChangeRequestsQuery
        @searchBy
    ): [ChangeRequest!]!
    @authAny
    @relation
    @paginatedRelation

    changeRequestsAggregated(
        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionChangeRequestsQuery
        @searchBy
    ): ChangeRequestsAggregated
    @authAny
    @aggregated(
        relation: "changeRequests"
    )

    changed_at: DateTime

    contacts(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseContactsSort!]
        @sortBy

        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionContactsQuery
        @searchBy
    ): [Contact!]!
    @authAny
    @relation
    @paginatedRelation

    contactsAggregated(
        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionContactsQuery
        @searchBy
    ): ContactsAggregated
    @authAny
    @aggregated(
        relation: "contacts"
    )

    contacts_active_quantity: Int
    contacts_count: Int!

    coverages: [Coverage!]
    @relation

    coverages_count: Int!
    created_at: DateTime!

    customer: Customer
    @relation

    customer_id: ID
    data_quality: String
    deleted_at: DateTime
    id: ID!

    location: Location
    @relation

    location_id: ID
    nickname: String

    oem: Oem
    @relation

    oem_id: ID

    product: Product
    @relation

    product_id: ID

    quoteRequest: QuoteRequest
    @relation

    reseller: Reseller
    @relation

    reseller_id: ID
    serial_number: String

    status: Status
    @relation

    status_id: ID
    synced_at: DateTime!

    tags: [Tag!]!
    @relation

    type: Type
    @relation

    type_id: ID
    updated_at: DateTime!

    warranties: [AssetWarranty!]!
    @relation(
        relation: "contractWarranties"
    )

    warrantyServiceGroup: ServiceGroup
    @relation

    warrantyServiceLevel: ServiceLevel
    @relation

    warranty_changed_at: DateTime
    warranty_end: Date
    warranty_service_group_id: ID
    warranty_service_level_id: ID
}

type AssetChangeRequestCreatePayload
implements
    & Payload
{
    changeRequest: ChangeRequest!
    result: Boolean!
}

type AssetChangeRequestMutation {
    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["requests-asset-change"])> User must be authenticated and have any of these permissions.
    """
    create(
        input: MessageInput!
    ): AssetChangeRequestCreatePayload!
    @authOrg
    @authMe(
        permissions: ["requests-asset-change"]
    )
    @mutationCreate(
        resolver: "App\\GraphQL\\Mutations\\Asset\\ChangeRequest\\Create"
    )
}

type AssetMutation {
    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    changeRequest: AssetChangeRequestMutation
    @authOrg
    @authMe
    @mutation(
        relation: "changeRequests"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["assets-view"])> User must be authenticated and have any of these permissions.

    @require <authMe(["assets-edit-nickname"])> User must be authenticated and have any of these permissions.
    """
    setNickname(
        input: AssetSetNicknameInput!
    ): AssetSetNicknamePayload
    @authOrg
    @authMe(
        permissions: ["assets-view"]
    )
    @authMe(
        permissions: ["assets-edit-nickname"]
    )
    @mutationMutate(
        resolver: "App\\GraphQL\\Mutations\\Asset\\SetNickname"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["assets-sync"])> User must be authenticated and have any of these permissions.
    """
    sync: AssetSyncPayload
    @authOrg
    @authMe(
        permissions: ["assets-sync"]
    )
    @mutationMutate(
        resolver: "App\\GraphQL\\Mutations\\Asset\\Sync"
    )
}

type AssetSetNicknamePayload
implements
    & Payload
{
    asset: Asset
    result: Boolean!
}

type AssetSyncPayload
implements
    & Payload
{
    result: Boolean!
    warranty: Boolean!
}

type AssetWarranty {
    customer: Customer
    @relation

    customer_id: ID
    description: String

    document: Document
    @relation

    document_id: ID
    document_number: String
    end: Date
    id: ID!

    reseller: Reseller
    @relation

    reseller_id: ID

    serviceGroup: ServiceGroup
    @relation

    serviceLevel: ServiceLevel
    @relation

    service_group_id: ID
    service_level_id: ID
    start: Date

    status: Status
    @relation

    status_id: String

    type: Type
    @relation

    type_id: String
}

"""
Aggregated data for `type Asset`.
"""
type AssetsAggregated {
    count: Int!
    @aggregatedCount
    @cached(
        mode: Threshold
    )

    coverages: [AssetsAggregatedCoverage!]!
    @field(
        resolver: "App\\GraphQL\\Queries\\Assets\\AssetsAggregated@coverages"
    )
    @cached

    groups(
        groupBy: AggregatedGroupByClauseAssetsQuery!
        @aggregatedGroupBy(
            order: "AssetsSort"
            where: "AssetsQuery"
        )

        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset
    ): [AggregatedGroupByTypeGroup!]!
    @cached(
        mode: Threshold
    )
    @paginated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )

    groupsAggregated(
        groupBy: AggregatedGroupByClauseAssetsQuery!
        @aggregatedGroupBy(
            order: "AssetsSort"
            where: "AssetsQuery"
        )
    ): AggregatedGroupByTypeGroupsAggregated
    @aggregated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )

    types: [AssetsAggregatedType!]!
    @field(
        resolver: "App\\GraphQL\\Queries\\Assets\\AssetsAggregated@types"
    )
    @cached
}

type AssetsAggregatedCoverage {
    count: Int!
    coverage: Type!
    coverage_id: ID!
}

type AssetsAggregatedType {
    count: Int!
    type: Type
    type_id: ID
}

"""
Aggregated data for `type Asset`.
"""
type AssetsSearchAggregated {
    count: Int!
    @aggregatedCount
    @cached(
        mode: Threshold
    )
}

type Audit {
    action: String!

    context: String
    @field(
        resolver: "App\\GraphQL\\Queries\\Administration\\AuditContext"
    )

    created_at: DateTime!
    id: ID!
    object_id: String
    object_type: String
    organization: Organization
    organization_id: ID
    user: User
    user_id: ID
}

"""
Aggregated data for `type Audit`.
"""
type AuditsAggregated {
    count: Int!
    @aggregatedCount
    @cached(
        mode: Threshold
    )

    groups(
        groupBy: AggregatedGroupByClauseAuditsQuery!
        @aggregatedGroupBy(
            order: "AuditsSort"
            where: "AuditsQuery"
        )

        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset
    ): [AggregatedGroupByTypeGroup!]!
    @cached(
        mode: Threshold
    )
    @paginated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )

    groupsAggregated(
        groupBy: AggregatedGroupByClauseAuditsQuery!
        @aggregatedGroupBy(
            order: "AuditsSort"
            where: "AuditsQuery"
        )
    ): AggregatedGroupByTypeGroupsAggregated
    @aggregated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )
}

type Auth {
    """
    @require <authGuest> Current visitor must be a guest.
    """
    invitation(
        token: String!
    ): AuthInvitation
    @authGuest
    @field(
        resolver: "App\\GraphQL\\Queries\\Auth\\Invitation"
    )
}

type AuthInvitation {
    """
    Indicates that the Invitation is expired and cannot be used.
    """
    expired: Boolean!
    @field(
        resolver: "App\\GraphQL\\Queries\\Auth\\Invitation@isExpired"
    )

    """
    Organization who sent the Invitation.
    """
    org: Org
    @field(
        resolver: "App\\GraphQL\\Queries\\Auth\\Invitation@org"
    )

    """
    Indicates that the new Invitation was sent so this one cannot be used anymore.
    """
    outdated: Boolean!
    @field(
        resolver: "App\\GraphQL\\Queries\\Auth\\Invitation@isOutdated"
    )

    """
    Indicates that the Invitation already used.
    """
    used: Boolean!
    @field(
        resolver: "App\\GraphQL\\Queries\\Auth\\Invitation@isUsed"
    )
}

type AuthMutation {
    """
    Organization Sign In.

    Application use standard OAuth 2.0 Authorization Code Grant.

    1. Call `signIn` mutation
        ```graphql
        mutation {
            auth {
                organization(id) {
                    signIn {
                        url
                    }
                }
            }
        }
        ```
    2. Redirect the User to `url`
    3. After successful Sign In the User will come back and Client should call
    `authorize` mutation with `code` and `state` to finish the authorization:
        ```graphql
        mutation {
            auth {
                organization(id) {
                    authorize(input: {code: "...", state: "..."}) {
                        result
                        me {
                            enabled
                        }
                    }
                }
            }
        }
        ```
    4. Check result:
    - `result = false` -> something wrong, please try to repeat step (1)
    - `me.enabled = false` -> user disabled or doesn't have access to the
    Organization. In this case, the Client should allow the User to
    Sign Out (so the User may repeat auth process if it want).

    @require <authGuest> Current visitor must be a guest.
    """
    organization(
        id: ID
        @eq
    ): AuthOrganizationMutation
    @authGuest
    @mutation(
        model: "App\\Models\\Organization"
    )

    """
    @require <authGuest> Current visitor must be a guest.
    """
    signIn(
        input: AuthSignInInput
    ): AuthSignInPayload
    @throttle(
        name: "auth"
    )
    @authGuest
    @mutationCall(
        resolver: "App\\GraphQL\\Mutations\\Auth\\SignIn"
    )

    signOut: AuthSignOutPayload
    @mutationCall(
        resolver: "App\\GraphQL\\Mutations\\Auth\\SignOut"
    )

    """
    Completes Sign Up.

    1. Call `auth { signUpByInvite(token: "...") { result, url } }` and redirect
    User to the `url` if `true`.
    2. If `false` you should provide addition details (`input`) to complete Sign Up
    process.

    See also:
    * `mutation { organization(id) { user { invite } }`
    * `mutation { org { user { invite } }`
    * `query { auth { invitation } }`

    @require <authGuest> Current visitor must be a guest.
    """
    signUpByInvite(
        input: AuthSignUpByInviteInput
        token: String!
    ): AuthSignUpByInvitePayload
    @authGuest
    @mutationCall(
        resolver: "App\\GraphQL\\Mutations\\Auth\\SignUpByInvite"
    )
}

type AuthOrganizationAuthorizePayload
implements
    & Payload
{
    me: Me
    result: Boolean!
}

type AuthOrganizationMutation {
    """
    @require <authGuest> Current visitor must be a guest.
    """
    authorize(
        input: AuthOrganizationAuthorizeInput!
    ): AuthOrganizationAuthorizePayload
    @authGuest
    @mutationMutate(
        resolver: "App\\GraphQL\\Mutations\\Auth\\Organization\\Authorize"
    )

    """
    @require <authGuest> Current visitor must be a guest.
    """
    signIn: AuthOrganizationSignInPayload
    @authGuest
    @mutationMutate(
        resolver: "App\\GraphQL\\Mutations\\Auth\\Organization\\SignIn"
    )
}

type AuthOrganizationSignInPayload
implements
    & Payload
{
    result: Boolean!

    """
    The link where the User should be redirected to Sign In.
    """
    url: Url!
}

type AuthSignInPayload
implements
    & Payload
{
    me: Me
    @field(
        resolver: "App\\GraphQL\\Queries\\Me"
    )

    org: Org
    @field(
        resolver: "App\\GraphQL\\Queries\\Org"
    )

    result: Boolean!
}

type AuthSignOutPayload
implements
    & Payload
{
    result: Boolean!

    """
    The link where the User should be redirected to complete Sign Out.
    """
    url: Url
}

type AuthSignUpByInvitePayload
implements
    & Payload
{
    """
    Organization who send the Invite.
    """
    org: Org

    result: Boolean!

    """
    The link where the User should be redirected to Sign In.
    """
    url: Url
}

type ChangeRequest {
    bcc: [String!]
    cc: [String!]
    created_at: DateTime!
    deleted_at: DateTime

    files: [File!]!
    @relation

    from: String!
    id: ID!
    message: String!
    subject: String!
    to: [String!]!
    updated_at: DateTime!

    user: User
    @relation

    user_id: ID!
}

"""
Aggregated data for `type ChangeRequest`.
"""
type ChangeRequestsAggregated {
    count: Int!
    @aggregatedCount
    @cached(
        mode: Threshold
    )

    groups(
        groupBy: AggregatedGroupByClauseChangeRequestsQuery!
        @aggregatedGroupBy(
            order: "ChangeRequestsSort"
            where: "ChangeRequestsQuery"
        )

        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset
    ): [AggregatedGroupByTypeGroup!]!
    @cached(
        mode: Threshold
    )
    @paginated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )

    groupsAggregated(
        groupBy: AggregatedGroupByClauseChangeRequestsQuery!
        @aggregatedGroupBy(
            order: "ChangeRequestsSort"
            where: "ChangeRequestsQuery"
        )
    ): AggregatedGroupByTypeGroupsAggregated
    @aggregated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )
}

type City {
    country: Country!
    @relation

    country_id: ID!
    id: ID!
    name: String!
}

type Client {
    settings: [ClientSetting!]!
    @field(
        resolver: "App\\GraphQL\\Queries\\Client\\Settings"
    )

    translations(
        locale: String!
        @rules(
            apply: ["App\\Rules\\Locale"]
        )
    ): [ClientTranslation!]!
    @field(
        resolver: "App\\GraphQL\\Queries\\Client\\Translations"
    )
}

type ClientSetting {
    name: String!

    """
    Value of the setting. For array it will contain comma-separated values, for
    Boolean: "true" or "false", also can be "null" that means null.
    """
    value: String!
}

type ClientTranslation {
    key: String!
    value: String!
}

type CompanyLocation {
    id: ID!

    location: Location
    @relation

    location_id: ID!

    types: [Type!]!
    @relation
}

"""
Aggregated data for `type CompanyLocation`.
"""
type CompanyLocationsAggregated {
    count: Int!
    @aggregatedCount
    @cached(
        mode: Threshold
    )

    groups(
        groupBy: AggregatedGroupByClauseCompanyLocationsQuery!
        @aggregatedGroupBy(
            order: "CompanyLocationsSort"
            where: "CompanyLocationsQuery"
        )

        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset
    ): [AggregatedGroupByTypeGroup!]!
    @cached(
        mode: Threshold
    )
    @paginated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )

    groupsAggregated(
        groupBy: AggregatedGroupByClauseCompanyLocationsQuery!
        @aggregatedGroupBy(
            order: "CompanyLocationsSort"
            where: "CompanyLocationsQuery"
        )
    ): AggregatedGroupByTypeGroupsAggregated
    @aggregated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )
}

type Contact {
    created_at: DateTime!
    deleted_at: DateTime
    email: Email
    id: ID!
    name: String
    phone_number: PhoneNumber

    """
    Indicates that phone_number in E.164 format
    """
    phone_valid: Boolean

    types: [Type]!
    @relation

    updated_at: DateTime!
}

"""
Aggregated data for `type Contact`.
"""
type ContactsAggregated {
    count: Int!
    @aggregatedCount
    @cached(
        mode: Threshold
    )

    groups(
        groupBy: AggregatedGroupByClauseContactsQuery!
        @aggregatedGroupBy(
            order: "ContactsSort"
            where: "ContactsQuery"
        )

        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset
    ): [AggregatedGroupByTypeGroup!]!
    @cached(
        mode: Threshold
    )
    @paginated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )

    groupsAggregated(
        groupBy: AggregatedGroupByClauseContactsQuery!
        @aggregatedGroupBy(
            order: "ContactsSort"
            where: "ContactsQuery"
        )
    ): AggregatedGroupByTypeGroupsAggregated
    @aggregated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )
}

type ContractChangeRequestCreatePayload
implements
    & Payload
{
    changeRequest: ChangeRequest!
    result: Boolean!
}

type ContractChangeRequestMutation {
    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["requests-contract-change"])> User must be authenticated and have any of these permissions.
    """
    create(
        input: MessageInput!
    ): ContractChangeRequestCreatePayload!
    @authOrg
    @authMe(
        permissions: ["requests-contract-change"]
    )
    @mutationCreate(
        resolver: "App\\GraphQL\\Mutations\\Document\\ChangeRequest\\Create"
    )
}

type ContractMutation {
    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    changeRequest: ContractChangeRequestMutation
    @authOrg
    @authMe
    @mutation(
        relation: "changeRequests"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["contracts-sync"])> User must be authenticated and have any of these permissions.
    """
    sync: ContractSyncPayload
    @authOrg
    @authMe(
        permissions: ["contracts-sync"]
    )
    @mutationMutate(
        resolver: "App\\GraphQL\\Mutations\\Document\\Sync"
    )
}

type ContractSyncPayload
implements
    & Payload
{
    assets: Boolean!
    result: Boolean!
}

type Country {
    code: String!
    id: ID!

    name: String!
    @translate
}

type Coverage {
    id: ID!
    key: String!

    name: String!
    @translate
}

type CreateContractNotePayload {
    created: Note!
}

type CreateMeSearchPayload {
    created: MeSearch!
}

type CreateQuoteNotePayload {
    created: Note!
}

type Currency {
    code: String!
    id: ID!

    name: String!
    @translate
}

type Customer
implements
    & Company
{
    """
    @require <authMe(["assets-view"])> User must be authenticated and have any of these permissions.
    """
    assets(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseAssetsSort!]
        @sortBy

        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionAssetsQuery
        @searchBy
    ): [Asset!]!
    @authMe(
        permissions: ["assets-view"]
    )
    @relation
    @paginatedRelation

    """
    @require <authMe(["assets-view"])> User must be authenticated and have any of these permissions.
    """
    assetsAggregated(
        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionAssetsQuery
        @searchBy
    ): AssetsAggregated
    @authMe(
        permissions: ["assets-view"]
    )
    @aggregated(
        relation: "assets"
    )

    assets_count: Int!
    @orgProperty

    changeRequests(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseChangeRequestsSort!]
        @sortBy

        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionChangeRequestsQuery
        @searchBy
    ): [ChangeRequest!]!
    @authAny
    @relation
    @paginatedRelation

    changeRequestsAggregated(
        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionChangeRequestsQuery
        @searchBy
    ): ChangeRequestsAggregated
    @authAny
    @aggregated(
        relation: "changeRequests"
    )

    changed_at: DateTime

    contacts(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseContactsSort!]
        @sortBy

        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionContactsQuery
        @searchBy
    ): [Contact!]!
    @authAny
    @relation
    @paginatedRelation

    contactsAggregated(
        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionContactsQuery
        @searchBy
    ): ContactsAggregated
    @authAny
    @aggregated(
        relation: "contacts"
    )

    contacts_count: Int!

    """
    @require <authMe(["contracts-view"])> User must be authenticated and have any of these permissions.
    """
    contracts(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseDocumentsSort!]
        @sortBy

        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionDocumentsQuery
        @searchBy
    ): [Document!]!
    @authMe(
        permissions: ["contracts-view"]
    )
    @relation
    @paginatedRelation

    """
    @require <authMe(["contracts-view"])> User must be authenticated and have any of these permissions.
    """
    contractsAggregated(
        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionDocumentsQuery
        @searchBy
    ): DocumentsAggregated
    @authMe(
        permissions: ["contracts-view"]
    )
    @aggregated(
        relation: "contracts"
    )

    contracts_count: Int!
    @orgProperty

    created_at: DateTime!
    deleted_at: DateTime

    headquarter: CompanyLocation
    @relation

    id: ID!

    kpi: Kpi
    @orgRelation

    locations(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseCompanyLocationsSort!]
        @sortBy

        where: SearchByConditionCompanyLocationsQuery
        @searchBy
    ): [CompanyLocation!]!
    @relation
    @paginatedRelation

    locationsAggregated(
        where: SearchByConditionCompanyLocationsQuery
        @searchBy
    ): CompanyLocationsAggregated
    @aggregated(
        relation: "locations"
    )

    locations_count: Int!
    name: String!

    """
    @require <authMe(["quotes-view"])> User must be authenticated and have any of these permissions.
    """
    quotes(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseDocumentsSort!]
        @sortBy

        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionDocumentsQuery
        @searchBy
    ): [Document!]!
    @authMe(
        permissions: ["quotes-view"]
    )
    @relation
    @paginatedRelation

    """
    @require <authMe(["quotes-view"])> User must be authenticated and have any of these permissions.
    """
    quotesAggregated(
        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionDocumentsQuery
        @searchBy
    ): DocumentsAggregated
    @authMe(
        permissions: ["quotes-view"]
    )
    @aggregated(
        relation: "quotes"
    )

    quotes_count: Int!
    @orgProperty

    statuses: [Status!]!
    @relation

    synced_at: DateTime!
    updated_at: DateTime!
}

type CustomerChangeRequestCreatePayload
implements
    & Payload
{
    changeRequest: ChangeRequest!
    result: Boolean!
}

type CustomerChangeRequestMutation {
    """
    @require <authOrgReseller> Authenticated user must be a member of the current organization, and
    the organization must be a Reseller (or a root organization).

    @require <authMe(["requests-customer-change"])> User must be authenticated and have any of these permissions.
    """
    create(
        input: MessageInput!
    ): CustomerChangeRequestCreatePayload!
    @authOrgReseller
    @authMe(
        permissions: ["requests-customer-change"]
    )
    @mutationCreate(
        resolver: "App\\GraphQL\\Mutations\\Customer\\ChangeRequest\\Create"
    )
}

type CustomerMutation {
    """
    @require <authOrgReseller> Authenticated user must be a member of the current organization, and
    the organization must be a Reseller (or a root organization).

    @require <authMe> User must be authenticated.
    """
    changeRequest: CustomerChangeRequestMutation
    @authOrgReseller
    @authMe
    @mutation(
        relation: "changeRequests"
    )

    """
    @require <authOrgReseller> Authenticated user must be a member of the current organization, and
    the organization must be a Reseller (or a root organization).

    @require <authMe(["customers-sync"])> User must be authenticated and have any of these permissions.
    """
    sync: CustomerSyncPayload
    @authOrgReseller
    @authMe(
        permissions: ["customers-sync"]
    )
    @mutationMutate(
        resolver: "App\\GraphQL\\Mutations\\Customer\\Sync"
    )
}

type CustomerSyncPayload
implements
    & Payload
{
    result: Boolean!
    warranty: Boolean!
}

"""
Aggregated data for `type Customer`.
"""
type CustomersAggregated {
    assets: Int!
    @field(
        resolver: "App\\GraphQL\\Queries\\Customers\\CustomersAggregated@assets"
    )
    @cached

    count: Int!
    @aggregatedCount
    @cached(
        mode: Threshold
    )

    groups(
        groupBy: AggregatedGroupByClauseCompaniesQuery!
        @aggregatedGroupBy(
            order: "CompaniesSort"
            where: "CompaniesQuery"
        )

        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset
    ): [AggregatedGroupByTypeGroup!]!
    @cached(
        mode: Threshold
    )
    @paginated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )

    groupsAggregated(
        groupBy: AggregatedGroupByClauseCompaniesQuery!
        @aggregatedGroupBy(
            order: "CompaniesSort"
            where: "CompaniesQuery"
        )
    ): AggregatedGroupByTypeGroupsAggregated
    @aggregated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )
}

"""
Aggregated data for `type Customer`.
"""
type CustomersSearchAggregated {
    count: Int!
    @aggregatedCount
    @cached(
        mode: Threshold
    )
}

type DeleteClientSettingsPayload {
    deleted: [String!]!
}

type DeleteContractNotePayload {
    deleted: Boolean!
}

type DeleteMeSearchPayload {
    deleted: Boolean!
}

type DeleteQuoteNotePayload {
    deleted: Boolean!
}

type DispatchApplicationServicePayload {
    result: Boolean!
}

type Distributor {
    created_at: DateTime!
    deleted_at: DateTime
    id: ID!
    name: String!
    updated_at: DateTime!
}

"""
Aggregated data for `type Distributor`.
"""
type DistributorsAggregated {
    count: Int!
    @aggregatedCount
    @cached(
        mode: Threshold
    )

    groups(
        groupBy: AggregatedGroupByClauseDistributorsQuery!
        @aggregatedGroupBy(
            order: "DistributorsSort"
            where: "DistributorsQuery"
        )

        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset
    ): [AggregatedGroupByTypeGroup!]!
    @cached(
        mode: Threshold
    )
    @paginated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )

    groupsAggregated(
        groupBy: AggregatedGroupByClauseDistributorsQuery!
        @aggregatedGroupBy(
            order: "DistributorsSort"
            where: "DistributorsQuery"
        )
    ): AggregatedGroupByTypeGroupsAggregated
    @aggregated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )
}

type Document {
    assets_count: Int

    changeRequests(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseChangeRequestsSort!]
        @sortBy

        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionChangeRequestsQuery
        @searchBy
    ): [ChangeRequest!]!
    @authAny
    @relation
    @paginatedRelation

    changeRequestsAggregated(
        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionChangeRequestsQuery
        @searchBy
    ): ChangeRequestsAggregated
    @authAny
    @aggregated(
        relation: "changeRequests"
    )

    changed_at: DateTime

    contacts(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseContactsSort!]
        @sortBy

        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionContactsQuery
        @searchBy
    ): [Contact!]!
    @authAny
    @relation
    @paginatedRelation

    contactsAggregated(
        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionContactsQuery
        @searchBy
    ): ContactsAggregated
    @authAny
    @aggregated(
        relation: "contacts"
    )

    contacts_count: Int!
    created_at: DateTime!

    currency: Currency
    @relation

    currency_id: ID

    customer: Customer
    @relation

    customer_id: ID
    deleted_at: DateTime

    distributor: Distributor
    @relation

    distributor_id: ID
    end: Date

    entries(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseDocumentEntriesSort!]
        @sortBy

        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionDocumentEntriesQuery
        @searchBy
    ): [DocumentEntry!]!
    @authAny
    @relation
    @paginatedRelation

    entriesAggregated(
        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionDocumentEntriesQuery
        @searchBy
    ): DocumentEntriesAggregated
    @authAny
    @aggregated(
        relation: "entries"
    )

    entries_count: Int!
    id: ID!
    is_contract: Boolean!
    is_quote: Boolean!

    language: Language
    @relation

    language_id: ID

    notes(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseNotesSort!]
        @sortBy

        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionNotesQuery
        @searchBy
    ): [Note!]!
    @authAny
    @relation
    @paginatedRelation

    notesAggregated(
        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionNotesQuery
        @searchBy
    ): NotesAggregated
    @authAny
    @aggregated(
        relation: "notes"
    )

    number: String

    oem: Oem
    @relation

    oemGroup: OemGroup
    @relation

    oem_amp_id: String
    oem_group_id: ID
    oem_id: ID
    oem_said: String
    oem_sar_number: String
    price: Float

    reseller: Reseller
    @relation

    reseller_id: ID
    start: Date

    statuses: [Status!]!
    @relation

    statuses_count: Int!
    synced_at: DateTime!

    type: Type
    @relation

    type_id: ID
    updated_at: DateTime!
}

"""
Aggregated data for `type DocumentEntry`.
"""
type DocumentEntriesAggregated {
    count: Int!
    @aggregatedCount
    @cached(
        mode: Threshold
    )

    groups(
        groupBy: AggregatedGroupByClauseDocumentEntriesQuery!
        @aggregatedGroupBy(
            order: "DocumentEntriesSort"
            where: "DocumentEntriesQuery"
        )

        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset
    ): [AggregatedGroupByTypeGroup!]!
    @cached(
        mode: Threshold
    )
    @paginated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )

    groupsAggregated(
        groupBy: AggregatedGroupByClauseDocumentEntriesQuery!
        @aggregatedGroupBy(
            order: "DocumentEntriesSort"
            where: "DocumentEntriesQuery"
        )
    ): AggregatedGroupByTypeGroupsAggregated
    @aggregated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )
}

type DocumentEntry {
    asset: Asset
    @relation

    assetType: Type
    @relation

    asset_id: ID
    asset_type_id: ID
    created_at: DateTime!

    currency: Currency
    @relation

    currency_id: ID
    deleted_at: DateTime
    document_id: ID!
    end: Date
    environment_id: String
    equipment_number: String
    id: ID!

    language: Language
    @relation

    language_id: ID
    list_price: Float
    monthly_list_price: Float
    monthly_retail_price: Float
    oem_said: String
    oem_sar_number: String

    product: Product
    @relation

    productGroup: ProductGroup
    @relation

    productLine: ProductLine
    @relation

    product_group_id: ID
    product_id: ID
    product_line_id: ID

    psp: Psp
    @relation

    psp_id: ID
    renewal: Float
    serial_number: String

    serviceGroup: ServiceGroup
    @relation

    serviceLevel: ServiceLevel
    @relation

    service_group_id: ID
    service_level_id: ID
    start: Date
    updated_at: DateTime!
}

"""
Aggregated data for `type Document`.
"""
type DocumentsAggregated {
    count: Int!
    @aggregatedCount
    @cached(
        mode: Threshold
    )

    groups(
        groupBy: AggregatedGroupByClauseDocumentsQuery!
        @aggregatedGroupBy(
            order: "DocumentsSort"
            where: "DocumentsQuery"
        )

        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset
    ): [AggregatedGroupByTypeGroup!]!
    @cached(
        mode: Threshold
    )
    @paginated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )

    groupsAggregated(
        groupBy: AggregatedGroupByClauseDocumentsQuery!
        @aggregatedGroupBy(
            order: "DocumentsSort"
            where: "DocumentsQuery"
        )
    ): AggregatedGroupByTypeGroupsAggregated
    @aggregated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )

    prices: [DocumentsAggregatedPrice!]!
    @field(
        resolver: "App\\GraphQL\\Queries\\Contracts\\ContractsAggregated@prices"
    )
    @cached
}

type DocumentsAggregatedPrice {
    amount: Float!
    count: Int!
    currency: Currency
    currency_id: ID
}

"""
Aggregated data for `type Document`.
"""
type DocumentsSearchAggregated {
    count: Int!
    @aggregatedCount
    @cached(
        mode: Threshold
    )
}

type File {
    id: ID!
    name: String!
    size: Int!
    url: Url!
}

type Invitation {
    email: Email!
    expired_at: DateTime!
    id: ID!
    organization_id: ID!

    role: Role
    @relation

    role_id: ID!

    team: Team
    @relation

    team_id: ID
    used_at: DateTime
}

type Kpi {
    assets_active: Int!
    assets_active_exposed: Int!
    assets_active_on_contract: Int!
    assets_active_on_warranty: Int!
    assets_active_percent: Float!
    assets_total: Int!
    contracts_active: Int!
    contracts_active_amount: Float!
    contracts_active_new: Int!
    contracts_expired: Int!
    contracts_expiring: Int!
    customers_active: Int!
    customers_active_new: Int!
    quotes_accepted: Int!
    quotes_active: Int!
    quotes_active_amount: Float!
    quotes_active_new: Int!
    quotes_awaiting: Int!
    quotes_expired: Int!
    quotes_expiring: Int!
    quotes_ordered: Int!
    quotes_received: Int!
    quotes_rejected: Int!
    quotes_requested: Int!
    service_revenue_total_amount: Float!
    service_revenue_total_amount_change: Float!
}

type Language {
    code: String!
    id: ID!

    name: String!
    @translate
}

type Locale {
    name: String!

    translations: [LocaleTranslation!]!
    @field(
        resolver: "App\\GraphQL\\Queries\\Administration\\Locale@translations"
    )
}

type LocaleImportPayload
implements
    & Payload
{
    result: Boolean!
}

type LocaleMutation {
    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authRoot> Authenticated user must be a root.
    """
    import(
        input: LocaleImportInput!
    ): LocaleImportPayload
    @authOrgRoot
    @authRoot
    @mutationMutate(
        resolver: "App\\GraphQL\\Mutations\\Locale\\Import"
    )

    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authRoot> Authenticated user must be a root.
    """
    reset: LocaleResetPayload
    @authOrgRoot
    @authRoot
    @mutationMutate(
        resolver: "App\\GraphQL\\Mutations\\Locale\\Reset"
    )

    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authRoot> Authenticated user must be a root.
    """
    update(
        input: LocaleUpdateInput!
    ): LocaleUpdatePayload
    @authOrgRoot
    @authRoot
    @mutationMutate(
        resolver: "App\\GraphQL\\Mutations\\Locale\\Update"
    )
}

type LocaleResetPayload
implements
    & Payload
{
    result: Boolean!
}

type LocaleTranslation {
    default: String
    key: String!
    value: String!
}

type LocaleUpdatePayload
implements
    & Payload
{
    result: Boolean!
}

type Location {
    city: City!
    @relation

    city_id: ID!

    country: Country!
    @relation

    country_id: ID!
    created_at: DateTime!
    deleted_at: DateTime
    id: ID!
    latitude: Float
    line_one: String!
    line_two: String!
    longitude: Float
    postcode: String!
    state: String!
    updated_at: DateTime!
}

type Map {
    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["assets-view"])> User must be authenticated and have any of these permissions.
    """
    assets: [MapPoint!]!
    @authOrg
    @authMe(
        permissions: ["assets-view"]
    )
    @field(
        resolver: "App\\GraphQL\\Queries\\Map\\Assets"
    )
    @cached(
        mode: Threshold
    )

    """
    @require <authOrgReseller> Authenticated user must be a member of the current organization, and
    the organization must be a Reseller (or a root organization).

    @require <authMe(["customers-view"])> User must be authenticated and have any of these permissions.
    """
    customers: [MapPoint!]!
    @authOrgReseller
    @authMe(
        permissions: ["customers-view"]
    )
    @field(
        resolver: "App\\GraphQL\\Queries\\Map\\Customers"
    )
    @cached(
        mode: Threshold
    )
}

type MapBoundingBox {
    eastLongitude: Float!
    northLatitude: Float!
    southLatitude: Float!
    westLongitude: Float!
}

type MapPoint {
    boundingBox: MapBoundingBox!
    latitude: Float!
    locations_count: Int!
    locations_ids: [ID!]!
    longitude: Float!
    objects_count: Int!
    objects_ids: [ID!]!
}

type Me {
    academic_title: String
    company: String
    contact_email: Email
    email: Email!

    enabled: Boolean!
    @field(
        resolver: "App\\GraphQL\\Queries\\Me@enabled"
    )

    family_name: String!
    given_name: String!
    homepage: String
    id: ID!
    job_title: String
    locale: String
    mobile_phone: PhoneNumber
    office_phone: PhoneNumber

    orgs: [Org!]!
    @field(
        resolver: "App\\GraphQL\\Queries\\Me@orgs"
    )

    permissions: [String!]
    phone: PhoneNumber
    photo: Url
    previous_sign_in: DateTime

    root: Boolean!
    @field(
        resolver: "App\\GraphQL\\Queries\\Me@root"
    )

    searches(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseMeSearchSort!]
        @sortBy

        where: SearchByConditionMeSearchQuery
        @searchBy
    ): [MeSearch!]!
    @relation
    @paginatedRelation

    searchesAggregated(
        where: SearchByConditionMeSearchQuery
        @searchBy
    ): MeSearchesAggregated
    @aggregated(
        relation: "searches"
    )

    team: Team
    @field(
        resolver: "App\\GraphQL\\Queries\\Me@team"
    )

    timezone: String
    title: String
}

type MeMutation {
    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    update(
        input: MeUpdateInput!
    ): MeUpdatePayload
    @authOrg
    @authMe
    @mutationMutate(
        resolver: "App\\GraphQL\\Mutations\\Me\\Update"
    )
}

type MeSearch {
    conditions: String!
    created_at: DateTime!
    deleted_at: DateTime
    id: ID!
    key: String!
    name: String!
    updated_at: DateTime!
}

"""
Aggregated data for `type MeSearch`.
"""
type MeSearchesAggregated {
    count: Int!
    @aggregatedCount
    @cached(
        mode: Threshold
    )

    groups(
        groupBy: AggregatedGroupByClauseMeSearchQuery!
        @aggregatedGroupBy(
            order: "MeSearchSort"
            where: "MeSearchQuery"
        )

        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset
    ): [AggregatedGroupByTypeGroup!]!
    @cached(
        mode: Threshold
    )
    @paginated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )

    groupsAggregated(
        groupBy: AggregatedGroupByClauseMeSearchQuery!
        @aggregatedGroupBy(
            order: "MeSearchSort"
            where: "MeSearchQuery"
        )
    ): AggregatedGroupByTypeGroupsAggregated
    @aggregated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )
}

type MeUpdatePayload
implements
    & Payload
{
    me: Me!
    result: Boolean!
}

type MessageCreatePayload
implements
    & Payload
{
    result: Boolean!
}

type MessageMutation {
    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    create(
        input: MessageInput!
    ): MessageCreatePayload!
    @authOrg
    @authMe
    @mutationCreate(
        resolver: "App\\GraphQL\\Mutations\\Message\\Create"
    )
}

type Mutation {
    application: ApplicationMutation
    @field(
        resolver: "App\\GraphQL\\Resolvers\\EmptyResolver"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    asset(
        id: ID
        @eq
    ): AssetMutation
    @authOrg
    @authMe
    @mutation(
        model: "App\\Models\\Asset"
    )

    auth: AuthMutation
    @mutation(
        resolver: "App\\GraphQL\\Resolvers\\NullResolver"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    contract(
        id: ID
        @eq
    ): ContractMutation
    @authOrg
    @authMe
    @builder(
        method: "App\\GraphQL\\Queries\\Contracts\\Contracts"
    )
    @mutation(
        model: "App\\Models\\Document"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["contracts-view"])> User must be authenticated and have any of these permissions.
    """
    createContractNote(
        input: CreateContractNoteInput!
    ): CreateContractNotePayload
    @authOrg
    @authMe(
        permissions: ["contracts-view"]
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    createMeSearch(
        input: CreateMeSearchInput!
    ): CreateMeSearchPayload
    @authOrg
    @authMe
    @field(
        resolver: "App\\GraphQL\\Mutations\\Me\\CreateMeSearch"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["quotes-view"])> User must be authenticated and have any of these permissions.
    """
    createQuoteNote(
        input: CreateQuoteNoteInput!
    ): CreateQuoteNotePayload
    @authOrg
    @authMe(
        permissions: ["quotes-view"]
    )

    """
    @require <authOrgReseller> Authenticated user must be a member of the current organization, and
    the organization must be a Reseller (or a root organization).

    @require <authMe> User must be authenticated.
    """
    customer(
        id: ID
        @eq
    ): CustomerMutation
    @authOrgReseller
    @authMe
    @mutation(
        model: "App\\Models\\Customer"
    )

    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authRoot> Authenticated user must be a root.
    """
    deleteClientSettings(
        input: DeleteClientSettingsInput!
    ): DeleteClientSettingsPayload
    @authOrgRoot
    @authRoot

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["contracts-view","org-administer"])> User must be authenticated and have any of these permissions.
    """
    deleteContractNote(
        input: DeleteContractNoteInput!
    ): DeleteContractNotePayload
    @authOrg
    @authMe(
        permissions: ["contracts-view", "org-administer"]
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    deleteMeSearch(
        input: DeleteMeSearchInput!
    ): DeleteMeSearchPayload
    @authOrg
    @authMe
    @field(
        resolver: "App\\GraphQL\\Mutations\\Me\\DeleteMeSearch"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["org-administer","quotes-view"])> User must be authenticated and have any of these permissions.
    """
    deleteQuoteNote(
        input: DeleteQuoteNoteInput!
    ): DeleteQuoteNotePayload
    @authOrg
    @authMe(
        permissions: ["quotes-view", "org-administer"]
    )

    """
    Dispatch/Run application service.

    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authRoot> Authenticated user must be a root.
    """
    dispatchApplicationService(
        input: DispatchApplicationServiceInput!
    ): DispatchApplicationServicePayload
    @authOrgRoot
    @authRoot
    @field(
        resolver: "App\\GraphQL\\Mutations\\Application\\DispatchApplicationService"
    )

    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authRoot> Authenticated user must be a root.
    """
    locale(
        name: String!
        @rules(
            apply: ["App\\Rules\\Locale"]
        )
    ): LocaleMutation
    @authOrgRoot
    @authRoot
    @mutation(
        resolver: "App\\GraphQL\\Queries\\Administration\\Locale"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    me: MeMutation
    @authOrg
    @authMe
    @mutation(
        resolver: "App\\GraphQL\\Queries\\Me"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    message: MessageMutation
    @authOrg
    @authMe
    @mutation(
        resolver: "App\\GraphQL\\Resolvers\\NullResolver"
    )

    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authMe(["administer"])> User must be authenticated and have any of these permissions.
    """
    oem: OemMutation
    @authOrgRoot
    @authMe(
        permissions: ["administer"]
    )
    @mutation(
        resolver: "App\\GraphQL\\Resolvers\\NullResolver"
    )

    """
    @require <authMe> User must be authenticated.
    """
    org: OrgMutation
    @authMe
    @mutation(
        resolver: "App\\GraphQL\\Queries\\Org"
    )

    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authMe(["administer"])> User must be authenticated and have any of these permissions.
    """
    organization(
        id: ID
        @eq
    ): OrganizationMutation
    @authOrgRoot
    @authMe(
        permissions: ["administer"]
    )
    @mutation(
        model: "App\\Models\\Organization"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    quote(
        id: ID
        @eq
    ): QuoteMutation
    @authOrg
    @authMe
    @builder(
        method: "App\\GraphQL\\Queries\\Quotes\\Quotes"
    )
    @mutation(
        model: "App\\Models\\Document"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    quoteRequest: QuoteRequestMutation
    @authOrg
    @authMe
    @mutation(
        model: "App\\Models\\QuoteRequest"
    )

    """
    Force delete all custom settings, may be useful to restore the corrupted file.

    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authRoot> Authenticated user must be a root.
    """
    recoverApplicationSettings: recoverApplicationSettingsPayload
    @authOrgRoot
    @authRoot
    @field(
        resolver: "App\\GraphQL\\Mutations\\Application\\RecoverApplicationSettings"
    )

    """
    Force delete all custom settings, may be useful to restore the corrupted file.

    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authRoot> Authenticated user must be a root.
    """
    recoverClientSettings: RecoverClientSettingsPayload
    @authOrgRoot
    @authRoot

    """
    Reset application service progress.

    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authRoot> Authenticated user must be a root.
    """
    resetApplicationService(
        input: ResetApplicationServiceInput!
    ): ResetApplicationServicePayload
    @authOrgRoot
    @authRoot
    @field(
        resolver: "App\\GraphQL\\Mutations\\Application\\ResetApplicationService"
    )

    """
    Send reset password link to the user.

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["org-administer"])> User must be authenticated and have any of these permissions.
    """
    resetOrgUserPassword(
        input: ResetOrgUserPasswordInput!
    ): ResetOrgUserPasswordPayload
    @authOrg
    @authMe(
        permissions: ["org-administer"]
    )
    @field(
        resolver: "App\\GraphQL\\Mutations\\Org\\ResetOrgUserPassword"
    )

    """
    Reset password.

    @require <authGuest> Current visitor must be a guest.
    """
    resetPassword(
        input: ResetPasswordInput
    ): ResetPasswordPayload
    @throttle(
        name: "auth"
    )
    @authGuest
    @field(
        resolver: "App\\GraphQL\\Mutations\\Auth\\ResetPassword"
    )

    """
    Send reset password link if local user with given email exists.

    @require <authGuest> Current visitor must be a guest.
    """
    sendResetPasswordLink(
        input: SendResetPasswordLinkInput
    ): SendResetPasswordLinkPayload
    @throttle(
        name: "auth"
    )
    @authGuest
    @field(
        resolver: "App\\GraphQL\\Mutations\\Auth\\SendResetPasswordLink"
    )

    setApplicationLocale(
        input: SetApplicationLocaleInput!
    ): SetApplicationLocalePayload
    @field(
        resolver: "App\\GraphQL\\Mutations\\Application\\SetApplicationLocale"
    )

    """
    Stop application service.

    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authRoot> Authenticated user must be a root.
    """
    stopApplicationService(
        input: StopApplicationServiceInput!
    ): StopApplicationServicePayload
    @authOrgRoot
    @authRoot
    @field(
        resolver: "App\\GraphQL\\Mutations\\Application\\StopApplicationService"
    )

    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authRoot> Authenticated user must be a root.
    """
    updateApplicationSettings(
        input: [UpdateApplicationSettingsInput!]!
    ): UpdateApplicationSettingsPayload
    @authOrgRoot
    @authRoot
    @field(
        resolver: "App\\GraphQL\\Mutations\\Application\\UpdateApplicationSettings"
    )

    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authRoot> Authenticated user must be a root.
    """
    updateClientSettings(
        input: [UpdateClientSettingsInput!]!
    ): UpdateClientSettingsPayload
    @authOrgRoot
    @authRoot

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["contracts-view"])> User must be authenticated and have any of these permissions.
    """
    updateContractNote(
        input: UpdateContractNoteInput!
    ): UpdateContractNotePayload
    @authOrg
    @authMe(
        permissions: ["contracts-view"]
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    updateMeEmail(
        input: UpdateMeEmailInput!
    ): UpdateMeEmailPayload
    @throttle(
        name: "auth"
    )
    @authOrg
    @authMe
    @field(
        resolver: "App\\GraphQL\\Mutations\\Me\\UpdateMeEmail"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    updateMePassword(
        input: UpdateMePasswordInput!
    ): UpdateMePasswordPayload
    @authOrg
    @authMe
    @field(
        resolver: "App\\GraphQL\\Mutations\\Me\\UpdateMePassword"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["quotes-view"])> User must be authenticated and have any of these permissions.
    """
    updateQuoteNote(
        input: UpdateQuoteNoteInput!
    ): UpdateQuoteNotePayload
    @authOrg
    @authMe(
        permissions: ["quotes-view"]
    )

    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authMe(["administer"])> User must be authenticated and have any of these permissions.
    """
    user(
        id: ID
        @eq
    ): UserMutation
    @authOrgRoot
    @authMe(
        permissions: ["administer"]
    )
    @mutation(
        model: "App\\Models\\User"
    )
}

type Note {
    changeRequest: ChangeRequest
    change_request_id: ID
    created_at: DateTime!
    deleted_at: DateTime

    files: [File!]!
    @relation

    id: ID!
    note: HtmlString
    pinned: Boolean!
    quoteRequest: QuoteRequest
    quote_request_id: ID
    updated_at: DateTime!

    user: User
    @relation

    user_id: ID!
}

"""
Aggregated data for `type Note`.
"""
type NotesAggregated {
    count: Int!
    @aggregatedCount
    @cached(
        mode: Threshold
    )

    groups(
        groupBy: AggregatedGroupByClauseNotesQuery!
        @aggregatedGroupBy(
            order: "NotesSort"
            where: "NotesQuery"
        )

        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset
    ): [AggregatedGroupByTypeGroup!]!
    @cached(
        mode: Threshold
    )
    @paginated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )

    groupsAggregated(
        groupBy: AggregatedGroupByClauseNotesQuery!
        @aggregatedGroupBy(
            order: "NotesSort"
            where: "NotesQuery"
        )
    ): AggregatedGroupByTypeGroupsAggregated
    @aggregated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )
}

type Oem {
    id: ID!
    key: String!
    name: String!
}

type OemGroup {
    created_at: DateTime!
    deleted_at: DateTime
    id: ID!
    key: String!
    name: String!
    updated_at: DateTime!
}

"""
Aggregated data for `type OemGroup`.
"""
type OemGroupsAggregated {
    count: Int!
    @aggregatedCount
    @cached(
        mode: Threshold
    )

    groups(
        groupBy: AggregatedGroupByClauseOemGroupsQuery!
        @aggregatedGroupBy(
            order: "OemGroupsSort"
            where: "OemGroupsQuery"
        )

        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset
    ): [AggregatedGroupByTypeGroup!]!
    @cached(
        mode: Threshold
    )
    @paginated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )

    groupsAggregated(
        groupBy: AggregatedGroupByClauseOemGroupsQuery!
        @aggregatedGroupBy(
            order: "OemGroupsSort"
            where: "OemGroupsQuery"
        )
    ): AggregatedGroupByTypeGroupsAggregated
    @aggregated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )
}

type OemHpeImportPayload
implements
    & Payload
{
    result: Boolean!
}

type OemHpeMutation {
    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authMe(["administer"])> User must be authenticated and have any of these permissions.
    """
    import(
        input: OemHpeImportInput!
    ): OemHpeImportPayload
    @authOrgRoot
    @authMe(
        permissions: ["administer"]
    )
    @mutationCall(
        resolver: "App\\GraphQL\\Mutations\\Oem\\Hpe\\Import"
    )
}

type OemMutation {
    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authMe(["administer"])> User must be authenticated and have any of these permissions.
    """
    hpe: OemHpeMutation
    @authOrgRoot
    @authMe(
        permissions: ["administer"]
    )
    @mutation(
        resolver: "App\\GraphQL\\Resolvers\\NullResolver"
    )
}

type Org {
    analytics_code: String

    branding: OrganizationBranding!
    @field(
        resolver: "App\\GraphQL\\Queries\\Org@branding"
    )

    currency: Currency
    @relation

    currency_id: ID
    email: Email

    headquarter: CompanyLocation
    @field(
        resolver: "App\\GraphQL\\Queries\\Org@headquarter"
    )

    id: ID!

    kpi: Kpi
    @field(
        resolver: "App\\GraphQL\\Queries\\Org@kpi"
    )

    locale: String
    name: String!

    """
    @require <authMe(["org-administer"])> User must be authenticated and have any of these permissions.
    """
    organization: Organization!
    @authMe(
        permissions: ["org-administer"]
    )
    @field(
        resolver: "App\\GraphQL\\Queries\\Org@organization"
    )

    timezone: String
    type: OrganizationType!
    website_url: Url
}

type OrgChangeRequestCreatePayload
implements
    & Payload
{
    changeRequest: ChangeRequest!
    result: Boolean!
}

type OrgChangeRequestMutation {
    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["org-administer"])> User must be authenticated and have any of these permissions.
    """
    create(
        input: MessageInput!
    ): OrgChangeRequestCreatePayload!
    @authOrg
    @authMe(
        permissions: ["org-administer"]
    )
    @mutationCreate(
        resolver: "App\\GraphQL\\Mutations\\Org\\ChangeRequest\\Create"
    )
}

type OrgMutation {
    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    changeRequest: OrgChangeRequestMutation
    @authOrg
    @authMe
    @mutation(
        relation: "changeRequests"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["org-administer"])> User must be authenticated and have any of these permissions.
    """
    role(
        id: ID
        @eq
    ): OrgRoleMutation
    @authOrg
    @authMe(
        permissions: ["org-administer"]
    )
    @mutation(
        builder: "App\\GraphQL\\Mutations\\Org\\Role\\Builder"
    )

    """
    @require <authMe> User must be authenticated.
    """
    set(
        input: OrgSetInput!
    ): OrgSetPayload
    @authMe
    @mutationCall(
        resolver: "App\\GraphQL\\Mutations\\Org\\Set"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["org-administer"])> User must be authenticated and have any of these permissions.
    """
    update(
        input: OrgUpdateInput!
    ): OrgUpdatePayload
    @authOrg
    @authMe(
        permissions: ["org-administer"]
    )
    @mutationMutate(
        resolver: "App\\GraphQL\\Mutations\\Org\\Update"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["org-administer"])> User must be authenticated and have any of these permissions.
    """
    user(
        id: ID
        @eq
    ): OrgUserMutation
    @authOrg
    @authMe(
        permissions: ["org-administer"]
    )
    @mutation(
        relation: "users"
    )
}

type OrgRoleCreatePayload
implements
    & Payload
{
    result: Boolean!
    role: Role!
}

type OrgRoleDeletePayload
implements
    & Payload
{
    result: Boolean!
}

type OrgRoleMutation {
    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["org-administer"])> User must be authenticated and have any of these permissions.
    """
    create(
        input: OrgRoleCreateInput!
    ): OrgRoleCreatePayload
    @authOrg
    @authMe(
        permissions: ["org-administer"]
    )
    @mutationCreate(
        resolver: "App\\GraphQL\\Mutations\\Org\\Role\\Create"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["org-administer"])> User must be authenticated and have any of these permissions.
    """
    delete: OrgRoleDeletePayload
    @authOrg
    @authMe(
        permissions: ["org-administer"]
    )
    @mutationMutate(
        resolver: "App\\GraphQL\\Mutations\\Org\\Role\\Delete"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["org-administer"])> User must be authenticated and have any of these permissions.
    """
    update(
        input: OrgRoleUpdateInput!
    ): OrgRoleUpdatePayload
    @authOrg
    @authMe(
        permissions: ["org-administer"]
    )
    @mutationMutate(
        resolver: "App\\GraphQL\\Mutations\\Org\\Role\\Update"
    )
}

type OrgRoleUpdatePayload
implements
    & Payload
{
    result: Boolean!
    role: Role!
}

type OrgSetPayload
implements
    & Payload
{
    me: Me
    @field(
        resolver: "App\\GraphQL\\Queries\\Me"
    )

    org: Org
    @field(
        resolver: "App\\GraphQL\\Queries\\Org"
    )

    result: Boolean!
}

type OrgUpdatePayload
implements
    & Payload
{
    org: Org!
    result: Boolean!
}

type OrgUserInvitePayload
implements
    & Payload
{
    result: Boolean!
}

type OrgUserMutation {
    """
    Adds user into Organization and send invite to join.

    To complete Sign Up the `mutation { auth { signUpByInvite } }` should be used.

    Please note that mutation will return `false` when:
    - User is already a member of the organization
    - User is disabled/banned
    - User is Root

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["org-administer"])> User must be authenticated and have any of these permissions.
    """
    invite(
        input: OrgUserInviteInput!
    ): OrgUserInvitePayload
    @authOrg
    @authMe(
        permissions: ["org-administer"]
    )
    @mutationCreate(
        resolver: "App\\GraphQL\\Mutations\\Org\\User\\Invite"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["org-administer"])> User must be authenticated and have any of these permissions.
    """
    update(
        input: OrgUserUpdateInput!
    ): OrgUserUpdatePayload
    @authOrg
    @authMe(
        permissions: ["org-administer"]
    )
    @mutationMutate(
        resolver: "App\\GraphQL\\Mutations\\Org\\User\\Update"
    )
}

type OrgUserUpdatePayload
implements
    & Payload
{
    result: Boolean!
    user: User!
}

type Organization {
    analytics_code: String

    """
    @require <authMe(["administer","org-administer"])> User must be authenticated and have any of these permissions.
    """
    audits(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseAuditsSort!]
        @sortBy

        where: SearchByConditionAuditsQuery
        @searchBy
    ): [Audit!]!
    @authMe(
        permissions: ["administer", "org-administer"]
    )
    @relation
    @paginatedRelation

    """
    @require <authMe(["administer","org-administer"])> User must be authenticated and have any of these permissions.
    """
    auditsAggregated(
        where: SearchByConditionAuditsQuery
        @searchBy
    ): AuditsAggregated
    @authMe(
        permissions: ["administer", "org-administer"]
    )
    @aggregated(
        relation: "audits"
    )

    branding: OrganizationBranding!
    @field(
        resolver: "App\\GraphQL\\Queries\\Organization@branding"
    )

    """
    @require <authMe(["administer","org-administer"])> User must be authenticated and have any of these permissions.
    """
    changeRequests(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseChangeRequestsSort!]
        @sortBy

        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionChangeRequestsQuery
        @searchBy
    ): [ChangeRequest!]!
    @authMe(
        permissions: ["administer", "org-administer"]
    )
    @relation
    @paginatedRelation

    """
    @require <authMe(["administer","org-administer"])> User must be authenticated and have any of these permissions.
    """
    changeRequestsAggregated(
        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionChangeRequestsQuery
        @searchBy
    ): ChangeRequestsAggregated
    @authMe(
        permissions: ["administer", "org-administer"]
    )
    @aggregated(
        relation: "changeRequests"
    )

    """
    @require <authMe(["administer"])> User must be authenticated and have any of these permissions.
    """
    company: Company
    @authMe(
        permissions: ["administer"]
    )
    @relation

    created_at: DateTime!

    currency: Currency
    @relation

    currency_id: ID
    deleted_at: DateTime
    email: Email
    id: ID!

    """
    @require <authMe(["administer"])> User must be authenticated and have any of these permissions.
    """
    keycloak_name: String
    @authMe(
        permissions: ["administer"]
    )

    """
    @require <authMe(["administer"])> User must be authenticated and have any of these permissions.
    """
    keycloak_scope: String
    @authMe(
        permissions: ["administer"]
    )

    locale: String
    name: String!

    """
    @require <authMe(["administer","org-administer"])> User must be authenticated and have any of these permissions.
    """
    roles: [Role!]!
    @authMe(
        permissions: ["administer", "org-administer"]
    )
    @relation

    root: Boolean!
    @field(
        resolver: "App\\GraphQL\\Queries\\Organization@root"
    )

    timezone: String
    type: OrganizationType!
    updated_at: DateTime!

    """
    @require <authMe(["administer","org-administer"])> User must be authenticated and have any of these permissions.
    """
    users(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseUsersSort!]
        @sortBy

        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionUsersQuery
        @searchBy
    ): [User!]!
    @authMe(
        permissions: ["administer", "org-administer"]
    )
    @relation
    @paginatedRelation

    """
    @require <authMe(["administer","org-administer"])> User must be authenticated and have any of these permissions.
    """
    usersAggregated(
        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionUsersQuery
        @searchBy
    ): UsersAggregated
    @authMe(
        permissions: ["administer", "org-administer"]
    )
    @aggregated(
        relation: "users"
    )

    website_url: Url
}

type OrganizationBranding {
    dark_theme: Boolean
    dashboard_image_url: Url
    default_favicon_url: Url
    default_logo_url: Url
    default_main_color: Color
    default_secondary_color: Color
    favicon_url: Url
    logo_url: Url
    main_color: Color
    secondary_color: Color
    welcome_heading: [TranslatedString!]
    welcome_image_url: Url
    welcome_underline: [TranslatedString!]
}

type OrganizationChangeRequestCreatePayload
implements
    & Payload
{
    changeRequest: ChangeRequest!
    result: Boolean!
}

type OrganizationChangeRequestMutation {
    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authMe(["administer"])> User must be authenticated and have any of these permissions.
    """
    create(
        input: MessageInput!
    ): OrganizationChangeRequestCreatePayload!
    @authOrgRoot
    @authMe(
        permissions: ["administer"]
    )
    @mutationCreate(
        resolver: "App\\GraphQL\\Mutations\\Organization\\ChangeRequest\\Create"
    )
}

type OrganizationMutation {
    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authMe(["administer"])> User must be authenticated and have any of these permissions.
    """
    changeRequest: OrganizationChangeRequestMutation
    @authOrgRoot
    @authMe(
        permissions: ["administer"]
    )
    @mutation(
        relation: "changeRequests"
    )

    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authMe(["administer"])> User must be authenticated and have any of these permissions.
    """
    user(
        id: ID
        @eq
    ): OrganizationUserMutation
    @authOrgRoot
    @authMe(
        permissions: ["administer"]
    )
    @mutation(
        relation: "users"
    )
}

type OrganizationUserInvitePayload
implements
    & Payload
{
    result: Boolean!
}

type OrganizationUserMutation {
    """
    Adds user into Organization and send invite to join.

    To complete Sign Up the `mutation { auth { signUpByInvite } }` should be used.

    Please note that mutation will return `false` when:
    - User is already a member of the organization
    - User is disabled/banned
    - User is Root

    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authMe(["administer"])> User must be authenticated and have any of these permissions.
    """
    invite(
        input: OrganizationUserInviteInput!
    ): OrganizationUserInvitePayload
    @authOrgRoot
    @authMe(
        permissions: ["administer"]
    )
    @mutationCreate(
        resolver: "App\\GraphQL\\Mutations\\Organization\\User\\Invite"
    )
}

"""
Aggregated data for `type Organization`.
"""
type OrganizationsAggregated {
    count: Int!
    @aggregatedCount
    @cached(
        mode: Threshold
    )

    groups(
        groupBy: AggregatedGroupByClauseOrganizationsQuery!
        @aggregatedGroupBy(
            order: "OrganizationsSort"
            where: "OrganizationsQuery"
        )

        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset
    ): [AggregatedGroupByTypeGroup!]!
    @cached(
        mode: Threshold
    )
    @paginated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )

    groupsAggregated(
        groupBy: AggregatedGroupByClauseOrganizationsQuery!
        @aggregatedGroupBy(
            order: "OrganizationsSort"
            where: "OrganizationsQuery"
        )
    ): AggregatedGroupByTypeGroupsAggregated
    @aggregated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )
}

type Permission {
    description: String!
    @translate

    id: ID!
    key: String!

    name: String!
    @translate
}

type Product {
    eol: Date
    eos: Date
    id: ID!
    name: String!

    oem: Oem!
    @relation

    oem_id: ID!
    sku: String!
}

type ProductGroup {
    id: ID!
    key: String!
    name: String!
}

type ProductLine {
    id: ID!
    key: String!
    name: String!
}

"""
Aggregated data for `type Product`.
"""
type ProductsAggregated {
    count: Int!
    @aggregatedCount
    @cached(
        mode: Threshold
    )

    groups(
        groupBy: AggregatedGroupByClauseProductsQuery!
        @aggregatedGroupBy(
            order: "ProductsSort"
            where: "ProductsQuery"
        )

        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset
    ): [AggregatedGroupByTypeGroup!]!
    @cached(
        mode: Threshold
    )
    @paginated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )

    groupsAggregated(
        groupBy: AggregatedGroupByClauseProductsQuery!
        @aggregatedGroupBy(
            order: "ProductsSort"
            where: "ProductsQuery"
        )
    ): AggregatedGroupByTypeGroupsAggregated
    @aggregated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )
}

type Psp {
    id: ID!
    key: String!
    name: String!
}

type Query {
    """
    Application information.
    """
    application: Application!
    @field(
        resolver: "App\\GraphQL\\Queries\\Application\\Application"
    )

    """
    Asset.

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["assets-view"])> User must be authenticated and have any of these permissions.
    """
    asset(
        id: ID!
        @eq
    ): Asset
    @authOrg
    @authMe(
        permissions: ["assets-view"]
    )
    @find

    """
    List of all possible asset coverages.

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["assets-view"])> User must be authenticated and have any of these permissions.
    """
    assetCoverages(
        where: SearchByConditionAssetCoveragesQuery
        @searchBy
    ): [Coverage!]!
    @authOrg
    @authMe(
        permissions: ["assets-view"]
    )
    @all(
        model: "App\\Models\\Data\\Coverage"
    )
    @cached

    """
    List of all possible asset statuses.

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["assets-view"])> User must be authenticated and have any of these permissions.
    """
    assetStatuses(
        where: SearchByConditionAssetStatusesQuery
        @searchBy
    ): [Status!]!
    @authOrg
    @authMe(
        permissions: ["assets-view"]
    )
    @all(
        builder: "App\\GraphQL\\Queries\\Assets\\AssetStatuses"
    )
    @cached

    """
    List of all possible asset types.

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["assets-view"])> User must be authenticated and have any of these permissions.
    """
    assetTypes(
        where: SearchByConditionAssetTypesQuery
        @searchBy
    ): [Type!]!
    @authOrg
    @authMe(
        permissions: ["assets-view"]
    )
    @all(
        builder: "App\\GraphQL\\Queries\\Assets\\AssetTypes"
    )
    @cached

    """
    List of all assets

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["assets-view"])> User must be authenticated and have any of these permissions.
    """
    assets(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseAssetsSort!]
        @sortBy

        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionAssetsQuery
        @searchBy
    ): [Asset!]!
    @authOrg
    @authMe(
        permissions: ["assets-view"]
    )
    @paginated

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["assets-view"])> User must be authenticated and have any of these permissions.
    """
    assetsAggregated(
        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionAssetsQuery
        @searchBy
    ): AssetsAggregated
    @authOrg
    @authMe(
        permissions: ["assets-view"]
    )
    @aggregated(
        model: "App\\Models\\Asset"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["assets-view"])> User must be authenticated and have any of these permissions.
    """
    assetsSearch(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseAssetsSearchSort!]
        @sortBy

        search: SearchString!
        @search
    ): [Asset!]!
    @authOrg
    @authMe(
        permissions: ["assets-view"]
    )
    @paginated

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["assets-view"])> User must be authenticated and have any of these permissions.
    """
    assetsSearchAggregated(
        search: SearchString!
        @search
    ): AssetsSearchAggregated
    @authOrg
    @authMe(
        permissions: ["assets-view"]
    )
    @aggregated(
        model: "App\\Models\\Asset"
    )

    """
    List of all organizations audits.

    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authMe(["administer"])> User must be authenticated and have any of these permissions.
    """
    audits(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseAuditsSort!]
        @sortBy

        where: SearchByConditionAuditsQuery
        @searchBy
    ): [Audit!]!
    @authOrgRoot
    @authMe(
        permissions: ["administer"]
    )
    @paginated(
        model: "App\\Models\\Audits\\Audit"
    )

    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authMe(["administer"])> User must be authenticated and have any of these permissions.
    """
    auditsAggregated(
        where: SearchByConditionAuditsQuery
        @searchBy
    ): AuditsAggregated
    @authOrgRoot
    @authMe(
        permissions: ["administer"]
    )
    @aggregated(
        model: "App\\Models\\Audits\\Audit"
    )

    """
    Auth data (invitations, etc).
    """
    auth: Auth
    @field(
        resolver: "App\\GraphQL\\Resolvers\\EmptyResolver"
    )

    """
    List of all cities.

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    cities(
        where: SearchByConditionCitiesQuery
        @searchBy
    ): [City!]!
    @authOrg
    @authMe
    @all
    @cached

    """
    Client data (settings, translations, etc).
    """
    client: Client
    @field(
        resolver: "App\\GraphQL\\Resolvers\\EmptyResolver"
    )

    """
    List of all possible contact types.

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    contactTypes(
        where: SearchByConditionContactTypesQuery
        @searchBy
    ): [Type!]!
    @authOrg
    @authMe
    @all(
        builder: "App\\GraphQL\\Queries\\Data\\ContactTypes"
    )
    @cached

    """
    Contract.

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["contracts-view"])> User must be authenticated and have any of these permissions.
    """
    contract(
        id: ID!
        @eq
    ): Document
    @authOrg
    @authMe(
        permissions: ["contracts-view"]
    )
    @builder(
        method: "App\\GraphQL\\Queries\\Contracts\\Contracts"
    )
    @find

    """
    List of all possible contract statuses.

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["contracts-view"])> User must be authenticated and have any of these permissions.
    """
    contractStatuses(
        where: SearchByConditionContractStatusesQuery
        @searchBy
    ): [Status!]!
    @authOrg
    @authMe(
        permissions: ["contracts-view"]
    )
    @all(
        builder: "App\\GraphQL\\Queries\\Contracts\\ContractStatuses"
    )
    @cached

    """
    List of all possible contract types.

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["contracts-view"])> User must be authenticated and have any of these permissions.
    """
    contractTypes(
        where: SearchByConditionContractTypesQuery
        @searchBy
    ): [Type!]!
    @authOrg
    @authMe(
        permissions: ["contracts-view"]
    )
    @all(
        builder: "App\\GraphQL\\Queries\\Contracts\\ContractTypes"
    )
    @cached

    """
    List of all contracts.

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["contracts-view"])> User must be authenticated and have any of these permissions.
    """
    contracts(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseDocumentsSort!]
        @sortBy

        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionDocumentsQuery
        @searchBy
    ): [Document!]!
    @authOrg
    @authMe(
        permissions: ["contracts-view"]
    )
    @builder(
        method: "App\\GraphQL\\Queries\\Contracts\\Contracts"
    )
    @paginated

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["contracts-view"])> User must be authenticated and have any of these permissions.
    """
    contractsAggregated(
        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionDocumentsQuery
        @searchBy
    ): DocumentsAggregated
    @authOrg
    @authMe(
        permissions: ["contracts-view"]
    )
    @builder(
        method: "App\\GraphQL\\Queries\\Contracts\\Contracts"
    )
    @aggregated(
        model: "App\\Models\\Document"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["contracts-view"])> User must be authenticated and have any of these permissions.
    """
    contractsSearch(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseDocumentsSearchSort!]
        @sortBy

        search: SearchString!
        @search
        @builder(
            method: "App\\GraphQL\\Queries\\Contracts\\ContractsSearch"
        )
    ): [Document!]!
    @authOrg
    @authMe(
        permissions: ["contracts-view"]
    )
    @paginated

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["contracts-view"])> User must be authenticated and have any of these permissions.
    """
    contractsSearchAggregated(
        search: SearchString!
        @search
        @builder(
            method: "App\\GraphQL\\Queries\\Contracts\\ContractsSearch"
        )
    ): DocumentsSearchAggregated
    @authOrg
    @authMe(
        permissions: ["contracts-view"]
    )
    @aggregated(
        model: "App\\Models\\Document"
    )

    """
    List of all countries.

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    countries(
        where: SearchByConditionCountriesQuery
        @searchBy
    ): [Country!]!
    @authOrg
    @authMe
    @all
    @cached

    """
    List of all currencies.

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    currencies(
        where: SearchByConditionCurrenciesQuery
        @searchBy
    ): [Currency!]!
    @authOrg
    @authMe
    @all
    @cached

    """
    Customer.

    @require <authOrgReseller> Authenticated user must be a member of the current organization, and
    the organization must be a Reseller (or a root organization).

    @require <authMe(["customers-view"])> User must be authenticated and have any of these permissions.
    """
    customer(
        id: ID!
        @eq
    ): Customer
    @authOrgReseller
    @authMe(
        permissions: ["customers-view"]
    )
    @find

    """
    List of all possible customer location types.

    @require <authOrgReseller> Authenticated user must be a member of the current organization, and
    the organization must be a Reseller (or a root organization).

    @require <authMe(["customers-view"])> User must be authenticated and have any of these permissions.
    """
    customerLocationTypes(
        where: SearchByConditionCustomerLocationTypesQuery
        @searchBy
    ): [Type!]!
    @authOrgReseller
    @authMe(
        permissions: ["customers-view"]
    )
    @all(
        builder: "App\\GraphQL\\Queries\\Customers\\CustomerLocationTypes"
    )
    @cached

    """
    List of all possible customer statuses.

    @require <authOrgReseller> Authenticated user must be a member of the current organization, and
    the organization must be a Reseller (or a root organization).

    @require <authMe(["customers-view"])> User must be authenticated and have any of these permissions.
    """
    customerStatuses(
        where: SearchByConditionCustomerStatusesQuery
        @searchBy
    ): [Status!]!
    @authOrgReseller
    @authMe(
        permissions: ["customers-view"]
    )
    @all(
        builder: "App\\GraphQL\\Queries\\Customers\\CustomerStatuses"
    )
    @cached

    """
    List of Customers.

    @require <authOrgReseller> Authenticated user must be a member of the current organization, and
    the organization must be a Reseller (or a root organization).

    @require <authMe(["customers-view"])> User must be authenticated and have any of these permissions.
    """
    customers(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseCompaniesSort!]
        @sortBy

        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionCompaniesQuery
        @searchBy
    ): [Customer!]!
    @authOrgReseller
    @authMe(
        permissions: ["customers-view"]
    )
    @paginated

    """
    @require <authOrgReseller> Authenticated user must be a member of the current organization, and
    the organization must be a Reseller (or a root organization).

    @require <authMe(["customers-view"])> User must be authenticated and have any of these permissions.
    """
    customersAggregated(
        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionCompaniesQuery
        @searchBy
    ): CustomersAggregated
    @authOrgReseller
    @authMe(
        permissions: ["customers-view"]
    )
    @aggregated(
        model: "App\\Models\\Customer"
    )

    """
    @require <authOrgReseller> Authenticated user must be a member of the current organization, and
    the organization must be a Reseller (or a root organization).

    @require <authMe(["customers-view"])> User must be authenticated and have any of these permissions.
    """
    customersSearch(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseCustomersSearchSort!]
        @sortBy

        search: SearchString!
        @search
    ): [Customer!]!
    @authOrgReseller
    @authMe(
        permissions: ["customers-view"]
    )
    @paginated

    """
    @require <authOrgReseller> Authenticated user must be a member of the current organization, and
    the organization must be a Reseller (or a root organization).

    @require <authMe(["customers-view"])> User must be authenticated and have any of these permissions.
    """
    customersSearchAggregated(
        search: SearchString!
        @search
    ): CustomersSearchAggregated
    @authOrgReseller
    @authMe(
        permissions: ["customers-view"]
    )
    @aggregated(
        model: "App\\Models\\Customer"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["assets-view","contracts-view","quotes-view"])> User must be authenticated and have any of these permissions.
    """
    distributors(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseDistributorsSort!]
        @sortBy

        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionDistributorsQuery
        @searchBy
    ): [Distributor!]!
    @authOrg
    @authMe(
        permissions: ["assets-view", "contracts-view", "quotes-view"]
    )
    @paginated

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["assets-view","contracts-view","quotes-view"])> User must be authenticated and have any of these permissions.
    """
    distributorsAggregated(
        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionDistributorsQuery
        @searchBy
    ): DistributorsAggregated
    @authOrg
    @authMe(
        permissions: ["assets-view", "contracts-view", "quotes-view"]
    )
    @aggregated(
        model: "App\\Models\\Distributor"
    )

    """
    List of all languages.

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    languages(
        where: SearchByConditionLanguagesQuery
        @searchBy
    ): [Language!]!
    @authOrg
    @authMe
    @all
    @cached

    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authRoot> Authenticated user must be a root.
    """
    locale(
        name: String!
        @rules(
            apply: ["App\\Rules\\Locale"]
        )
    ): Locale!
    @authOrgRoot
    @authRoot
    @field(
        resolver: "App\\GraphQL\\Queries\\Administration\\Locale"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    map(
        """
        Assets filters.
        """
        assets: SearchByConditionAssetsQuery
        @searchBy

        """
        Only points inside these boundaries will be returned.
        """
        boundaries: [Geohash!]

        """
        Zoom level (1-12).
        """
        level: Int!
        @rules(
            apply: ["App\\Rules\\MapLevel"]
        )

        """
        Additional filters for the points.
        """
        locations: SearchByConditionMapQuery
        @searchBy
    ): Map!
    @authOrg
    @authMe
    @field(
        resolver: "App\\GraphQL\\Queries\\Map\\Map"
    )

    """
    Authenticated user or `null` otherwise.
    """
    me: Me
    @field(
        resolver: "App\\GraphQL\\Queries\\Me"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    oemGroups(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseOemGroupsSort!]
        @sortBy

        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionOemGroupsQuery
        @searchBy
    ): [OemGroup!]!
    @authOrg
    @authMe
    @paginated

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    oemGroupsAggregated(
        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionOemGroupsQuery
        @searchBy
    ): OemGroupsAggregated
    @authOrg
    @authMe
    @aggregated(
        model: "App\\Models\\OemGroup"
    )

    """
    List of all OEMs

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    oems(
        where: SearchByConditionOemsQuery
        @searchBy
    ): [Oem!]!
    @authOrg
    @authMe
    @all
    @cached

    """
    Current organization.
    """
    org: Org
    @field(
        resolver: "App\\GraphQL\\Queries\\Org"
    )

    """
    Organization.

    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authMe(["administer"])> User must be authenticated and have any of these permissions.
    """
    organization(
        id: ID!
        @eq
    ): Organization
    @authOrgRoot
    @authMe(
        permissions: ["administer"]
    )
    @find

    """
    List of all organizations.

    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authMe(["administer"])> User must be authenticated and have any of these permissions.
    """
    organizations(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseOrganizationsSort!]
        @sortBy

        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionOrganizationsQuery
        @searchBy
    ): [Organization!]!
    @authOrgRoot
    @authMe(
        permissions: ["administer"]
    )
    @paginated

    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authMe(["administer"])> User must be authenticated and have any of these permissions.
    """
    organizationsAggregated(
        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionOrganizationsQuery
        @searchBy
    ): OrganizationsAggregated
    @authOrgRoot
    @authMe(
        permissions: ["administer"]
    )
    @aggregated(
        model: "App\\Models\\Organization"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["administer","org-administer"])> User must be authenticated and have any of these permissions.
    """
    permissions: [Permission!]!
    @authOrg
    @authMe(
        permissions: ["administer", "org-administer"]
    )
    @field(
        resolver: "App\\GraphQL\\Queries\\Permissions"
    )

    """
    List of all products.

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    products(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseProductsSort!]
        @sortBy

        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionProductsQuery
        @searchBy
    ): [Product!]!
    @authOrg
    @authMe
    @paginated

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    productsAggregated(
        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionProductsQuery
        @searchBy
    ): ProductsAggregated
    @authOrg
    @authMe
    @aggregated(
        model: "App\\Models\\Data\\Product"
    )

    """
    Quote.

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["quotes-view"])> User must be authenticated and have any of these permissions.
    """
    quote(
        id: ID!
        @eq
    ): Document
    @authOrg
    @authMe(
        permissions: ["quotes-view"]
    )
    @builder(
        method: "App\\GraphQL\\Queries\\Quotes\\Quotes"
    )
    @find

    """
    List of all possible quote request durations.

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    quoteRequestDurations: [QuoteRequestDuration!]!
    @authOrg
    @authMe
    @all
    @cached

    """
    List of all possible quote statuses.

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["quotes-view"])> User must be authenticated and have any of these permissions.
    """
    quoteStatuses(
        where: SearchByConditionQuoteStatusesQuery
        @searchBy
    ): [Status!]!
    @authOrg
    @authMe(
        permissions: ["quotes-view"]
    )
    @all(
        builder: "App\\GraphQL\\Queries\\Quotes\\QuoteStatuses"
    )
    @cached

    """
    List of all possible quote types.

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["quotes-view"])> User must be authenticated and have any of these permissions.
    """
    quoteTypes(
        where: SearchByConditionQuoteTypesQuery
        @searchBy
    ): [Type!]!
    @authOrg
    @authMe(
        permissions: ["quotes-view"]
    )
    @all(
        builder: "App\\GraphQL\\Queries\\Quotes\\QuoteTypes"
    )
    @cached

    """
    List of all quotes.

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["quotes-view"])> User must be authenticated and have any of these permissions.
    """
    quotes(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseDocumentsSort!]
        @sortBy

        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionDocumentsQuery
        @searchBy
    ): [Document!]!
    @authOrg
    @authMe(
        permissions: ["quotes-view"]
    )
    @builder(
        method: "App\\GraphQL\\Queries\\Quotes\\Quotes"
    )
    @paginated

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["quotes-view"])> User must be authenticated and have any of these permissions.
    """
    quotesAggregated(
        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionDocumentsQuery
        @searchBy
    ): DocumentsAggregated
    @authOrg
    @authMe(
        permissions: ["quotes-view"]
    )
    @builder(
        method: "App\\GraphQL\\Queries\\Quotes\\Quotes"
    )
    @aggregated(
        model: "App\\Models\\Document"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["quotes-view"])> User must be authenticated and have any of these permissions.
    """
    quotesSearch(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseDocumentsSearchSort!]
        @sortBy

        search: SearchString!
        @search
        @builder(
            method: "App\\GraphQL\\Queries\\Quotes\\QuotesSearch"
        )
    ): [Document!]!
    @authOrg
    @authMe(
        permissions: ["quotes-view"]
    )
    @paginated

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["quotes-view"])> User must be authenticated and have any of these permissions.
    """
    quotesSearchAggregated(
        search: SearchString!
        @search
        @builder(
            method: "App\\GraphQL\\Queries\\Quotes\\QuotesSearch"
        )
    ): DocumentsSearchAggregated
    @authOrg
    @authMe(
        permissions: ["quotes-view"]
    )
    @aggregated(
        model: "App\\Models\\Document"
    )

    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authMe> User must be authenticated.
    """
    resellers(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseCompaniesSort!]
        @sortBy

        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionCompaniesQuery
        @searchBy
    ): [Reseller!]!
    @authOrgRoot
    @authMe
    @paginated

    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authMe> User must be authenticated.
    """
    resellersAggregated(
        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionCompaniesQuery
        @searchBy
    ): ResellersAggregated
    @authOrgRoot
    @authMe
    @aggregated(
        model: "App\\Models\\Reseller"
    )

    """
    List of all shared roles.

    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authMe(["administer"])> User must be authenticated and have any of these permissions.
    """
    roles: [Role!]!
    @authOrgRoot
    @authMe(
        permissions: ["administer"]
    )
    @builder(
        method: "App\\GraphQL\\Queries\\Administration\\Roles"
    )
    @all

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["assets-view","contracts-view","customers-view","quotes-view"])> User must be authenticated and have any of these permissions.
    """
    search(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        search: SearchString!
        @search
        @builder(
            method: "App\\GraphQL\\Queries\\Search"
        )
    ): [SearchResult!]!
    @authOrg
    @authMe(
        permissions: [
            "customers-view"
            "assets-view"
            "quotes-view"
            "contracts-view"
        ]
    )
    @paginated(
        builder: "App\\GraphQL\\Queries\\Search@builder"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["assets-view","contracts-view","customers-view","quotes-view"])> User must be authenticated and have any of these permissions.
    """
    searchAggregated(
        search: SearchString!
        @search
        @builder(
            method: "App\\GraphQL\\Queries\\Search"
        )
    ): SearchResultsSearchAggregated
    @authOrg
    @authMe(
        permissions: [
            "customers-view"
            "assets-view"
            "quotes-view"
            "contracts-view"
        ]
    )
    @aggregated(
        builder: "App\\GraphQL\\Queries\\Search@builder"
    )

    """
    List of all Service Groups.

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    serviceGroups(
        where: SearchByConditionServiceGroupsQuery
        @searchBy
    ): [ServiceGroup!]!
    @authOrg
    @authMe
    @all
    @cached

    """
    List of all Service Levels.

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    serviceLevels(
        where: SearchByConditionServiceLevelsQuery
        @searchBy
    ): [ServiceLevel!]!
    @authOrg
    @authMe
    @all
    @cached

    """
    List of all possible tags.

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    tags(
        order: [SortByClauseTag!]
        @sortBy

        where: SearchByConditionTagsQuery
        @searchBy
    ): [Tag!]!
    @authOrg
    @authMe
    @all
    @cached

    """
    List of all possible teams.

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["administer","org-administer"])> User must be authenticated and have any of these permissions.
    """
    teams: [Team!]!
    @authOrg
    @authMe(
        permissions: ["administer", "org-administer"]
    )
    @all

    """
    List of all Timezones

    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    timezones: [String!]!
    @authOrg
    @authMe
    @field(
        resolver: "App\\GraphQL\\Queries\\Data\\Timezones"
    )
    @cached

    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authMe(["administer"])> User must be authenticated and have any of these permissions.
    """
    user(
        id: ID!
        @eq
    ): User
    @authOrgRoot
    @authMe(
        permissions: ["administer"]
    )
    @builder(
        method: "App\\GraphQL\\Queries\\Administration\\Users"
    )
    @find

    """
    List of all users.

    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authMe(["administer"])> User must be authenticated and have any of these permissions.
    """
    users(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseUsersSort!]
        @sortBy

        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionUsersQuery
        @searchBy
    ): [User!]!
    @authOrgRoot
    @authMe(
        permissions: ["administer"]
    )
    @builder(
        method: "App\\GraphQL\\Queries\\Administration\\Users"
    )
    @paginated

    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authMe(["administer"])> User must be authenticated and have any of these permissions.
    """
    usersAggregated(
        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionUsersQuery
        @searchBy
    ): UsersAggregated
    @authOrgRoot
    @authMe(
        permissions: ["administer"]
    )
    @builder(
        method: "App\\GraphQL\\Queries\\Administration\\Users"
    )
    @aggregated(
        model: "App\\Models\\User"
    )
}

type QuoteChangeRequestCreatePayload
implements
    & Payload
{
    changeRequest: ChangeRequest!
    result: Boolean!
}

type QuoteChangeRequestMutation {
    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["requests-quote-change"])> User must be authenticated and have any of these permissions.
    """
    create(
        input: MessageInput!
    ): QuoteChangeRequestCreatePayload!
    @authOrg
    @authMe(
        permissions: ["requests-quote-change"]
    )
    @mutationCreate(
        resolver: "App\\GraphQL\\Mutations\\Document\\ChangeRequest\\Create"
    )
}

type QuoteMutation {
    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe> User must be authenticated.
    """
    changeRequest: QuoteChangeRequestMutation
    @authOrg
    @authMe
    @mutation(
        relation: "changeRequests"
    )

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["quotes-sync"])> User must be authenticated and have any of these permissions.
    """
    sync: QuoteSyncPayload
    @authOrg
    @authMe(
        permissions: ["quotes-sync"]
    )
    @mutationMutate(
        resolver: "App\\GraphQL\\Mutations\\Document\\Sync"
    )
}

type QuoteRequest {
    assets: [QuoteRequestAsset!]!
    @relation

    contact: Contact!
    @relation

    customer: Customer
    @relation

    customer_custom: String
    customer_id: ID

    documents: [QuoteRequestDocument!]!
    @relation

    files: [File!]!
    @relation

    id: ID!
    message: String

    oem: Oem
    @relation

    oem_custom: String
    oem_id: ID

    type: Type
    @relation

    type_custom: String
    type_id: ID

    user: User
    @relation

    user_id: ID!
}

type QuoteRequestAsset {
    asset: Asset
    @relation

    asset_id: ID!

    duration: QuoteRequestDuration!
    @relation

    duration_id: ID!
    id: ID!

    serviceLevel: ServiceLevel
    @relation

    service_level_custom: String
    service_level_id: ID
}

type QuoteRequestCreatePayload
implements
    & Payload
{
    quoteRequest: QuoteRequest
    result: Boolean!
}

type QuoteRequestDocument {
    document: Document
    @relation

    document_id: ID!

    duration: QuoteRequestDuration!
    @relation

    duration_id: ID!
    id: ID!
}

type QuoteRequestDuration {
    id: ID!
    key: String!

    name: String!
    @translate
}

type QuoteRequestMutation {
    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["requests-quote-add"])> User must be authenticated and have any of these permissions.
    """
    create(
        input: QuoteRequestCreateInput!
    ): QuoteRequestCreatePayload!
    @authOrg
    @authMe(
        permissions: ["requests-quote-add"]
    )
    @mutationCreate(
        resolver: "App\\GraphQL\\Mutations\\QuoteRequest\\Create"
    )
}

type QuoteSyncPayload {
    assets: Boolean!
    result: Boolean!
}

type RecoverClientSettingsPayload {
    result: Boolean!
}

type Reseller
implements
    & Company
{
    """
    @require <authMe(["assets-view"])> User must be authenticated and have any of these permissions.
    """
    assets(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseAssetsSort!]
        @sortBy

        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionAssetsQuery
        @searchBy
    ): [Asset!]!
    @authMe(
        permissions: ["assets-view"]
    )
    @relation
    @paginatedRelation

    """
    @require <authMe(["assets-view"])> User must be authenticated and have any of these permissions.
    """
    assetsAggregated(
        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionAssetsQuery
        @searchBy
    ): AssetsAggregated
    @authMe(
        permissions: ["assets-view"]
    )
    @aggregated(
        relation: "assets"
    )

    assets_count: Int!
    @orgProperty

    changed_at: DateTime

    contacts(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseContactsSort!]
        @sortBy

        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionContactsQuery
        @searchBy
    ): [Contact!]!
    @authAny
    @relation
    @paginatedRelation

    contactsAggregated(
        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionContactsQuery
        @searchBy
    ): ContactsAggregated
    @authAny
    @aggregated(
        relation: "contacts"
    )

    contacts_count: Int!

    """
    @require <authMe(["contracts-view"])> User must be authenticated and have any of these permissions.
    """
    contracts(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseDocumentsSort!]
        @sortBy

        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionDocumentsQuery
        @searchBy
    ): [Document!]!
    @authMe(
        permissions: ["contracts-view"]
    )
    @relation
    @paginatedRelation

    """
    @require <authMe(["contracts-view"])> User must be authenticated and have any of these permissions.
    """
    contractsAggregated(
        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionDocumentsQuery
        @searchBy
    ): DocumentsAggregated
    @authMe(
        permissions: ["contracts-view"]
    )
    @aggregated(
        relation: "contracts"
    )

    created_at: DateTime!
    customers_count: Int!
    deleted_at: DateTime

    headquarter: CompanyLocation
    @relation

    id: ID!

    kpi: Kpi
    @orgRelation

    locations(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseCompanyLocationsSort!]
        @sortBy

        where: SearchByConditionCompanyLocationsQuery
        @searchBy
    ): [CompanyLocation!]!
    @relation
    @paginatedRelation

    locationsAggregated(
        where: SearchByConditionCompanyLocationsQuery
        @searchBy
    ): CompanyLocationsAggregated
    @aggregated(
        relation: "locations"
    )

    locations_count: Int!
    name: String!

    """
    @require <authMe(["quotes-view"])> User must be authenticated and have any of these permissions.
    """
    quotes(
        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset

        order: [SortByClauseDocumentsSort!]
        @sortBy

        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionDocumentsQuery
        @searchBy
    ): [Document!]!
    @authMe(
        permissions: ["quotes-view"]
    )
    @relation
    @paginatedRelation

    """
    @require <authMe(["quotes-view"])> User must be authenticated and have any of these permissions.
    """
    quotesAggregated(
        trashed: Trashed
        @authMe(
            permissions: ["administer"]
        )
        @paginatedTrashed

        where: SearchByConditionDocumentsQuery
        @searchBy
    ): DocumentsAggregated
    @authMe(
        permissions: ["quotes-view"]
    )
    @aggregated(
        relation: "quotes"
    )

    statuses: [Status!]!
    @relation

    synced_at: DateTime!
    updated_at: DateTime!
}

"""
Aggregated data for `type Reseller`.
"""
type ResellersAggregated {
    count: Int!
    @aggregatedCount
    @cached(
        mode: Threshold
    )

    groups(
        groupBy: AggregatedGroupByClauseCompaniesQuery!
        @aggregatedGroupBy(
            order: "CompaniesSort"
            where: "CompaniesQuery"
        )

        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset
    ): [AggregatedGroupByTypeGroup!]!
    @cached(
        mode: Threshold
    )
    @paginated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )

    groupsAggregated(
        groupBy: AggregatedGroupByClauseCompaniesQuery!
        @aggregatedGroupBy(
            order: "CompaniesSort"
            where: "CompaniesQuery"
        )
    ): AggregatedGroupByTypeGroupsAggregated
    @aggregated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )
}

type ResetApplicationServicePayload {
    result: Boolean!
}

type ResetOrgUserPasswordPayload {
    result: Boolean!
}

type ResetPasswordPayload {
    result: Boolean!
}

type Role {
    id: ID!
    name: String!

    permissions: [Permission!]!
    @relation
}

"""
Aggregated data for `union SearchResult`.
"""
type SearchResultsSearchAggregated {
    count: Int!
    @aggregatedCount
    @cached(
        mode: Threshold
    )
}

type SendResetPasswordLinkPayload {
    result: Boolean!
}

type ServiceGroup {
    id: ID!

    name: String!
    @translate

    oem: Oem!
    @relation

    oem_id: ID!
    sku: String!
}

type ServiceLevel {
    description: String!
    @translate

    id: ID!

    name: String!
    @translate

    oem: Oem!
    @relation

    oem_id: ID!

    serviceGroup: ServiceGroup!
    @relation

    service_group_id: ID!
    sku: String!
}

type SetApplicationLocalePayload {
    result: Boolean!
}

type Status {
    id: ID!
    key: String!

    name: String!
    @translate
}

type StopApplicationServicePayload {
    result: Boolean!
}

type StringValue {
    value: String!
}

type Tag {
    id: ID!
    name: String!
}

type Team {
    id: ID!
    name: String!
}

type TranslatedString {
    locale: String!
    text: String!
}

type Type {
    id: ID!
    key: String!

    name: String!
    @translate
}

type UpdateApplicationSettingsPayload {
    updated: [ApplicationSetting!]!
}

type UpdateClientSettingsPayload {
    updated: [ClientSetting!]!
}

type UpdateContractNotePayload {
    updated: Note!
}

type UpdateMeEmailPayload {
    result: Boolean!
}

type UpdateMePasswordPayload {
    result: Boolean!
}

type UpdateQuoteNotePayload {
    updated: Note!
}

type User {
    academic_title: String
    company: String
    contact_email: Email
    created_at: DateTime!
    deleted_at: DateTime
    email: Email!
    email_verified: Boolean!
    enabled: Boolean!
    family_name: String
    given_name: String
    id: ID!

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["administer","org-administer"])> User must be authenticated and have any of these permissions.
    """
    invitations: [Invitation!]!
    @authOrg
    @authMe(
        permissions: ["administer", "org-administer"]
    )
    @relation

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["administer","org-administer"])> User must be authenticated and have any of these permissions.
    """
    invitations_count: Int!
    @authOrg
    @authMe(
        permissions: ["administer", "org-administer"]
    )
    @count(
        relation: "invitations"
    )

    job_title: String
    locale: String
    mobile_phone: PhoneNumber
    office_phone: PhoneNumber

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["administer","org-administer"])> User must be authenticated and have any of these permissions.
    """
    organizations: [UserOrganization!]!
    @authOrg
    @authMe(
        permissions: ["administer", "org-administer"]
    )
    @relation

    """
    @require <authOrg> Authenticated user must be a member of the current organization.

    @require <authMe(["administer","org-administer"])> User must be authenticated and have any of these permissions.
    """
    organizations_count: Int!
    @authOrg
    @authMe(
        permissions: ["administer", "org-administer"]
    )
    @count(
        relation: "organizations"
    )

    phone: PhoneNumber
    photo: Url
    previous_sign_in: DateTime
    timezone: String
    title: String
    updated_at: DateTime!
}

type UserMutation {
    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authMe(["administer"])> User must be authenticated and have any of these permissions.
    """
    organization(
        id: ID
        @eq(
            key: "organization_id"
        )
    ): UserOrganizationMutation
    @authOrgRoot
    @authMe(
        permissions: ["administer"]
    )
    @mutation(
        relation: "organizations"
    )

    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authMe(["administer"])> User must be authenticated and have any of these permissions.
    """
    update(
        input: UserUpdateInput!
    ): UserUpdatePayload
    @authOrgRoot
    @authMe(
        permissions: ["administer"]
    )
    @mutationMutate(
        resolver: "App\\GraphQL\\Mutations\\User\\Update"
    )
}

type UserOrganization {
    enabled: Boolean!
    organization: Organization!
    organization_id: ID!
    role: Role

    status: Status!
    @field(
        resolver: "App\\GraphQL\\Queries\\Administration\\User@status"
    )

    team: Team
}

type UserOrganizationMutation {
    """
    @require <authOrgRoot> Authenticated user must be a member of the current organization, and
    the organization must be a root organization.

    @require <authMe(["administer"])> User must be authenticated and have any of these permissions.
    """
    update(
        input: UserOrganizationUpdateInput!
    ): UserOrganizationUpdatePayload
    @authOrgRoot
    @authMe(
        permissions: ["administer"]
    )
    @mutationMutate(
        resolver: "App\\GraphQL\\Mutations\\User\\Organization\\Update"
    )
}

type UserOrganizationUpdatePayload
implements
    & Payload
{
    organization: UserOrganization!
    result: Boolean!
}

type UserUpdatePayload
implements
    & Payload
{
    result: Boolean!
    user: User!
}

"""
Aggregated data for `type User`.
"""
type UsersAggregated {
    count: Int!
    @aggregatedCount
    @cached(
        mode: Threshold
    )

    groups(
        groupBy: AggregatedGroupByClauseUsersQuery!
        @aggregatedGroupBy(
            order: "UsersSort"
            where: "UsersQuery"
        )

        limit: Int! = 25
        @rules(
            apply: [
                "min:1"
                "App\\GraphQL\\Directives\\Directives\\Paginated\\LimitRule"
            ]
        )
        @paginatedLimit

        offset: Int! = 0
        @rules(
            apply: ["min:0"]
        )
        @paginatedOffset
    ): [AggregatedGroupByTypeGroup!]!
    @cached(
        mode: Threshold
    )
    @paginated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )

    groupsAggregated(
        groupBy: AggregatedGroupByClauseUsersQuery!
        @aggregatedGroupBy(
            order: "UsersSort"
            where: "UsersQuery"
        )
    ): AggregatedGroupByTypeGroupsAggregated
    @aggregated(
        builder: "App\\GraphQL\\Directives\\Directives\\Aggregated\\Builder"
    )
}

type recoverApplicationSettingsPayload {
    result: Boolean!
}

union ApplicationSettingValues =
    | Status
    | StringValue
    | Type

union SearchResult =
    | Asset
    | Customer
    | Document

"""
Gets the current builder and passed it to children. At least one argument required.
"""
directive @aggregated(
    """
    Point to a function that provides a Query Builder instance.
    This replaces the use of a model.
    """
    builder: String

    """
    Specify the class name of the model to use.
    This is only needed when the default model detection does not work.
    """
    model: String

    """
    Specify the relation name to use.
    """
    relation: String
)
on
    | FIELD_DEFINITION

"""
Returns `count(*)`.
"""
directive @aggregatedCount
on
    | FIELD_DEFINITION

directive @aggregatedGroupBy(
    order: String
    where: String
)
on
    | ARGUMENT_DEFINITION

directive @aggregatedGroupByOperatorAsDate
on
    | INPUT_FIELD_DEFINITION

directive @aggregatedGroupByOperatorAsString
on
    | INPUT_FIELD_DEFINITION

directive @aggregatedGroupByOperatorRelation
on
    | INPUT_FIELD_DEFINITION

"""
Fetch all Eloquent models and return the collection as the result.
"""
directive @all(
    """
    Point to a function that provides a Query Builder instance.
    This replaces the use of a model.
    """
    builder: String

    """
    Specify the class name of the model to use.
    This is only needed when the default model detection does not work.
    """
    model: String

    """
    Apply scopes to the underlying query.
    """
    scopes: [String!]
)
on
    | FIELD_DEFINITION

"""
Everyone/Everything allowed.
"""
directive @authAny
on
    | ARGUMENT_DEFINITION
    | FIELD_DEFINITION
    | OBJECT

"""
Current visitor must be a guest.
"""
directive @authGuest
on
    | ARGUMENT_DEFINITION
    | FIELD_DEFINITION
    | OBJECT

"""
User must be authenticated.
"""
directive @authMe(
    """
    User must be authenticated and have any of these permissions.
    """
    permissions: [String!]
)
repeatable on
    | ARGUMENT_DEFINITION
    | FIELD_DEFINITION
    | OBJECT

"""
Authenticated user must be a member of the current organization.
"""
directive @authOrg
on
    | ARGUMENT_DEFINITION
    | FIELD_DEFINITION
    | OBJECT

"""
Authenticated user must be a member of the current organization, and
the organization must be a Reseller (or a root organization).
"""
directive @authOrgReseller
on
    | ARGUMENT_DEFINITION
    | FIELD_DEFINITION
    | OBJECT

"""
Authenticated user must be a member of the current organization, and
the organization must be a root organization.
"""
directive @authOrgRoot
on
    | ARGUMENT_DEFINITION
    | FIELD_DEFINITION
    | OBJECT

"""
Authenticated user must be a root.
"""
directive @authRoot
on
    | ARGUMENT_DEFINITION
    | FIELD_DEFINITION
    | OBJECT

"""
Manipulate the query builder with a method.
"""
directive @builder(
    """
    Reference a method that is passed the query builder.
    Consists of two parts: a class name and a method name, separated by an `@` symbol.
    If you pass only a class name, the method name defaults to `__invoke`.
    """
    method: String!

    """
    Pass a value to the method as the second argument after the query builder.
    Only used when the directive is added on a field.
    """
    value: BuilderValue
)
repeatable on
    | ARGUMENT_DEFINITION
    | FIELD_DEFINITION
    | INPUT_FIELD_DEFINITION

"""
Cache the resolved value of a field.
"""
directive @cached(
    mode: CachedMode
)
on
    | FIELD_DEFINITION

"""
Returns the count of a given relationship or model.
"""
directive @count(
    """
    Count only rows where the given columns are non-null.
    `*` counts every row.
    """
    columns: [String!]! = ["*"]

    """
    Should exclude duplicated rows?
    """
    distinct: Boolean! = false

    """
    The model to count.
    Mutually exclusive with the `relation` argument.
    """
    model: String

    """
    The relationship to count.
    Mutually exclusive with the `model` argument.
    """
    relation: String

    """
    Apply scopes to the underlying query.
    """
    scopes: [String!]
)
on
    | FIELD_DEFINITION

"""
Add an equal conditional to a database query.
"""
directive @eq(
    """
    Specify the database column to compare.
    Required if the directive is:
    - used on an argument and the database column has a different name
    - used on a field
    """
    key: String

    """
    Provide a value to compare against.
    Only required when this directive is used on a field.
    """
    value: EqValue
)
repeatable on
    | ARGUMENT_DEFINITION
    | FIELD_DEFINITION
    | INPUT_FIELD_DEFINITION

"""
Assign a resolver function to a field.
"""
directive @field(
    """
    Supply additional data to the resolver.
    """
    args: [String!]

    """
    A reference to the resolver function to be used.
    Consists of two parts: a class name and a method name, seperated by an `@` symbol.
    If you pass only a class name, the method name defaults to `__invoke`.
    """
    resolver: String!
)
on
    | FIELD_DEFINITION

"""
Find a model based on the arguments provided.
"""
directive @find(
    """
    Specify the class name of the model to use.
    This is only needed when the default model detection does not work.
    """
    model: String

    """
    Apply scopes to the underlying query.
    """
    scopes: [String!]
)
on
    | FIELD_DEFINITION

directive @isAssetId
on
    | INPUT_FIELD_DEFINITION

directive @isColor
on
    | INPUT_FIELD_DEFINITION

directive @isCurrencyId
on
    | INPUT_FIELD_DEFINITION

directive @isCustomerId
on
    | INPUT_FIELD_DEFINITION

directive @isDistinct
on
    | INPUT_FIELD_DEFINITION

directive @isDocumentId
on
    | INPUT_FIELD_DEFINITION

directive @isEmail
on
    | INPUT_FIELD_DEFINITION

directive @isFile
on
    | INPUT_FIELD_DEFINITION

directive @isImage
on
    | INPUT_FIELD_DEFINITION

directive @isLocale
on
    | INPUT_FIELD_DEFINITION

directive @isMax(
    value: Int!
)
on
    | INPUT_FIELD_DEFINITION

directive @isNotMe
on
    | INPUT_FIELD_DEFINITION

directive @isNullable
on
    | INPUT_FIELD_DEFINITION

directive @isOemId
on
    | INPUT_FIELD_DEFINITION

directive @isOrgPermissionId
on
    | INPUT_FIELD_DEFINITION

directive @isOrgRoleId
on
    | INPUT_FIELD_DEFINITION

directive @isOrganizationId
on
    | INPUT_FIELD_DEFINITION

directive @isOrganizationRoleId
on
    | INPUT_FIELD_DEFINITION

directive @isPhoneNumber
on
    | INPUT_FIELD_DEFINITION

directive @isProhibitedUnless(
    field: String!
    value: String
)
on
    | INPUT_FIELD_DEFINITION

directive @isQuoteRequestDurationId
on
    | INPUT_FIELD_DEFINITION

directive @isQuoteTypeId
on
    | INPUT_FIELD_DEFINITION

directive @isRequired
on
    | INPUT_FIELD_DEFINITION

directive @isRequiredWithout(
    field: String!
)
on
    | INPUT_FIELD_DEFINITION

directive @isServiceLevelId
on
    | INPUT_FIELD_DEFINITION

directive @isSpreadsheet
on
    | INPUT_FIELD_DEFINITION

directive @isTeamId
on
    | INPUT_FIELD_DEFINITION

directive @isTimezone
on
    | INPUT_FIELD_DEFINITION

directive @isUrl
on
    | INPUT_FIELD_DEFINITION

"""
Resolves the root for nested mutations.
"""
directive @mutation(
    """
    Point to a function that provides a Query Builder instance.
    This replaces the use of a `model` and `relation`.
    """
    builder: String

    """
    Specify the class name of the model to use.
    This is only needed when the default model detection does not work.
    """
    model: String

    """
    Specify the relation name to use.
    This replaces the use of a `model`.
    """
    relation: String

    """
    Reference to a function that resolve the field.
    This replaces the use of a `model`, `relation` and `builder`.
    Must return `Model` or `null`.
    """
    resolver: String
)
on
    | FIELD_DEFINITION

"""
Indicates that field is the mutation.
"""
directive @mutationCall(
    """
    Reference to a function that executes mutation.
    """
    resolver: String!
)
on
    | FIELD_DEFINITION

"""
Indicates that field is the mutation.
"""
directive @mutationCreate(
    """
    Reference to a function that executes mutation.
    """
    resolver: String!
)
on
    | FIELD_DEFINITION

"""
Indicates that field is the mutation.
"""
directive @mutationMutate(
    """
    Reference to a function that executes mutation.
    """
    resolver: String!
)
on
    | FIELD_DEFINITION

"""
Return property value for current organization.
"""
directive @orgProperty
on
    | FIELD_DEFINITION
    | INPUT_FIELD_DEFINITION

"""
Return relation value for current organization.
"""
directive @orgRelation
on
    | FIELD_DEFINITION

"""
Adds offset-based pagination for the field.
"""
directive @paginated(
    """
    Point to a function that provides a Query Builder instance.
    This replaces the use of a model.
    """
    builder: String

    """
    Specify the class name of the model to use.
    This is only needed when the default model detection does not work.
    """
    model: String
)
on
    | FIELD_DEFINITION

"""
Adds limit clause to the builder.
"""
directive @paginatedLimit
on
    | ARGUMENT_DEFINITION

"""
Adds offset clause to the builder.
"""
directive @paginatedOffset
on
    | ARGUMENT_DEFINITION

"""
Adds offset-based pagination for the relation.
"""
directive @paginatedRelation
on
    | FIELD_DEFINITION

"""
Adds `withTrashed()` to the builder.
"""
directive @paginatedTrashed
on
    | ARGUMENT_DEFINITION

"""
Eloquent relationship.
"""
directive @relation(
    """
    Relationship name if it is named different from the field in the schema.
    """
    relation: String
)
on
    | FIELD_DEFINITION

"""
Validate an argument using [Laravel validation](https://laravel.com/docs/validation).
"""
directive @rules(
    """
    Specify the validation rules to apply to the field.
    This can either be a reference to [Laravel's built-in validation rules](https://laravel.com/docs/validation#available-validation-rules),
    or the fully qualified class name of a custom validation rule.

    Rules that mutate the incoming arguments, such as `exclude_if`, are not supported
    by Lighthouse. Use ArgTransformerDirectives or FieldMiddlewareDirectives instead.
    """
    apply: [String!]!

    """
    Specify a custom attribute name to use in your validation message.
    """
    attribute: String

    """
    Specify the messages to return if the validators fail.
    """
    messages: [RulesMessage!]
)
repeatable on
    | ARGUMENT_DEFINITION
    | INPUT_FIELD_DEFINITION

"""
Reference a class implementing a scalar definition.
"""
directive @scalar(
    """
    Reference to a class that extends `\GraphQL\Type\Definition\ScalarType`.
    """
    class: String!
)
on
    | SCALAR

"""
Perform a full-text search by the given input value.
"""
directive @search(
    """
    Specify a custom index to use for search.
    """
    within: String
)
on
    | ARGUMENT_DEFINITION
    | INPUT_FIELD_DEFINITION

"""
Use Input as Search Conditions for the current Builder.
"""
directive @searchBy
on
    | ARGUMENT_DEFINITION

directive @searchByOperatorAllOf
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorAnyOf
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorBetween
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorBitwiseAnd
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorBitwiseLeftShift
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorBitwiseOr
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorBitwiseRightShift
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorBitwiseXor
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorContains
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorEndsWith
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorEqual
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorGreaterThan
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorGreaterThanOrEqual
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorIn
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorIsNotNull
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorIsNull
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorLessThan
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorLessThanOrEqual
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorNot
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorNotBetween
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorNotEqual
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorNotIn
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorRelation
on
    | INPUT_FIELD_DEFINITION

directive @searchByOperatorStartsWith
on
    | INPUT_FIELD_DEFINITION

directive @searchByProperty
on
    | INPUT_FIELD_DEFINITION

"""
Convert Input into Sort Clause.
"""
directive @sortBy
on
    | ARGUMENT_DEFINITION

directive @sortByOperatorProperty
on
    | INPUT_FIELD_DEFINITION

directive @sortByProperty
on
    | INPUT_FIELD_DEFINITION

"""
Sets rate limit to access the field. Does the same as ThrottleRequests Laravel Middleware.
"""
directive @throttle(
    """
    Time in minutes to reset attempts.
    """
    decayMinutes: Float = 1

    """
    Maximum number of attempts in a specified time interval.
    """
    maxAttempts: Int = 60

    """
    Named preconfigured rate limiter. Requires Laravel 8.x or later.
    """
    name: String

    """
    Prefix to distinguish several field groups.
    """
    prefix: String
)
on
    | FIELD_DEFINITION

"""
Translates Model/Object property.

Model/Object must implements App\\Services\\I18n\\Contracts\\Translatable.
"""
directive @translate
on
    | FIELD_DEFINITION

"""
Provide validation rules through a PHP class.
"""
directive @validator(
    """
    The name of the class to use.

    If defined on an input, this defaults to a class called `{$inputName}Validator` in the
    default validator namespace. For fields, it uses the namespace of the parent type
    and the field name: `{$parent}\{$field}Validator`.
    """
    class: String
)
repeatable on
    | ARGUMENT_DEFINITION
    | FIELD_DEFINITION
    | INPUT_FIELD_DEFINITION
    | INPUT_OBJECT
